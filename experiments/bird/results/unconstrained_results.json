[
  {
    "idx": 0,
    "db_id": "california_schools",
    "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
    "evidence": "Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`",
    "gold_sql": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
    "predicted_sql": "SELECT \n  frpm.count AS 'Free Meal Count (K-12)',\n  enrollment.k12 AS 'Enrollment (K-12)',\n  ROUND(frpm.count / enrollment.k12, 2) AS 'Eligible Free Rate (K-12)'\nFROM \n  frpm\n  JOIN schools ON frpm.cdscode = schools.cdscode\nWHERE \n  schools.county_code = '011'\n  AND frpm.low_grade = 'K-12'\nORDER BY \n  'Eligible Free Rate (K-12)' DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: frpm.count",
    "difficulty": "simple"
  },
  {
    "idx": 1,
    "db_id": "california_schools",
    "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
    "evidence": "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
    "gold_sql": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
    "predicted_sql": "SELECT \n  frpm.count AS frpm_count, \n  ROUND(frpm.count / enrollment.count, 4) AS eligible_free_rate\nFROM \n  california_schools.frpm \n  INNER JOIN \n    california_schools.schools \n  ON \n    frpm.cdscode = schools.cdscode \nWHERE \n  schools.statustype = 'Continuation' \n  AND frpm.count > 0 \n  AND enrollment.count > 0 \nORDER BY \n  eligible_free_rate \nLIMIT \n  3",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 2,
    "db_id": "california_schools",
    "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
    "evidence": "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm",
    "gold_sql": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
    "predicted_sql": "SELECT s.zip\nFROM schools s\nJOIN frpm f ON s.cdscode = f.cdscode\nWHERE f.charter_school = '1' AND s.county = 'Fresno'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.charter_school",
    "difficulty": "simple"
  },
  {
    "idx": 3,
    "db_id": "california_schools",
    "question": "What is the unabbreviated mailing street address of the school with the highest FRPM count for K-12 students?",
    "evidence": "",
    "gold_sql": "SELECT T2.MailStreet FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.street, \n  s.streetabr, \n  s.city, \n  s.zip, \n  s.state, \n  COUNT(f.frpm_count) AS frpm_count\nFROM \n  schools s\n  LEFT JOIN frpm f ON s.cdscode = f.cdscode\nWHERE \n  f.frpm_count > 0\nGROUP BY \n  s.street, \n  s.streetabr, \n  s.city, \n  s.zip, \n  s.state\nORDER BY \n  frpm_count DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.frpm_count",
    "difficulty": "simple"
  },
  {
    "idx": 4,
    "db_id": "california_schools",
    "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
    "evidence": "Charter schools refers to `Charter School (Y/N)` = 1 in the frpm",
    "gold_sql": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
    "predicted_sql": "SELECT s.phone\nFROM frpm f\nJOIN schools s ON f.cdscode = s.cdscode\nWHERE f.charter_school = '1' AND s.opendate > '2000-01-01'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.charter_school",
    "difficulty": "moderate"
  },
  {
    "idx": 5,
    "db_id": "california_schools",
    "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
    "evidence": "Exclusively virtual refers to Virtual = 'F'",
    "gold_sql": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
    "predicted_sql": "SELECT COUNT(*)\nFROM satscores\nWHERE avgscrmath > 400\nAND Virtual = 'F'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: Virtual",
    "difficulty": "simple"
  },
  {
    "idx": 6,
    "db_id": "california_schools",
    "question": "Among the schools with the SAT test takers of over 500, please list the schools that are magnet schools or offer a magnet program.",
    "evidence": "Magnet schools or offer a magnet program means that Magnet = 1",
    "gold_sql": "SELECT T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Magnet = 1 AND T1.NumTstTakr > 500",
    "predicted_sql": "SELECT s.sname, s.dname, s.cname\nFROM schools s\nJOIN satscores ss ON s.cdscode = ss.cds\nWHERE ss.numtsttakr > 500 AND s.magnet = 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.sname",
    "difficulty": "simple"
  },
  {
    "idx": 7,
    "db_id": "california_schools",
    "question": "What is the phone number of the school that has the highest number of test takers with an SAT score of over 1500?",
    "evidence": "",
    "gold_sql": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
    "predicted_sql": "SELECT s.phone\nFROM satscores s\nJOIN schools sch ON s.cds = sch.cdscode\nWHERE s.numtsttakr > 0 AND s.avgscrread > 1500\nORDER BY s.numtsttakr DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.phone",
    "difficulty": "simple"
  },
  {
    "idx": 8,
    "db_id": "california_schools",
    "question": "What is the number of SAT test takers of the schools with the highest FRPM count for K-12 students?",
    "evidence": "",
    "gold_sql": "SELECT NumTstTakr FROM satscores WHERE cds = ( SELECT CDSCode FROM frpm ORDER BY `FRPM Count (K-12)` DESC LIMIT 1 )",
    "predicted_sql": "SELECT \n    COUNT(DISTINCT satscores.cds) AS num_sat_test_takers\nFROM \n    satscores\nJOIN \n    frpm ON satscores.cds = frpm.cdscode\nWHERE \n    frpm.percent_eligible_frpm_k12 IS NOT NULL\nORDER BY \n    frpm.percent_eligible_frpm_k12 DESC\nLIMIT \n    1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: frpm.percent_eligible_frpm_k12",
    "difficulty": "simple"
  },
  {
    "idx": 9,
    "db_id": "california_schools",
    "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(T2.`School Code`) FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath > 560 AND T2.`Charter Funding Type` = 'Directly funded'",
    "predicted_sql": "SELECT COUNT(*) \nFROM schools s\nJOIN satscores sc ON s.cdscode = sc.cds\nWHERE sc.avgscrmath > 560 AND s.charter = 'y'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 10,
    "db_id": "california_schools",
    "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
    "evidence": "",
    "gold_sql": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.name, \n  s.county, \n  s.district, \n  s.school, \n  f.frpm_count_ages_5_17 \nFROM \n  schools s \n  JOIN frpm f ON s.cdscode = f.cdscode \n  JOIN satscores sc ON s.cdscode = sc.cdscode \nWHERE \n  sc.rtype = 'SAT' AND \n  sc.avgscrread = (SELECT MAX(avgscrread) FROM satscores) \n  AND f.enrollment_ages_5_17 > 0 \nORDER BY \n  s.name",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.name",
    "difficulty": "simple"
  },
  {
    "idx": 11,
    "db_id": "california_schools",
    "question": "Please list the codes of the schools with a total enrollment of over 500.",
    "evidence": "Total enrollment can be represented by `Enrollment (K-12)` + `Enrollment (Ages 5-17)`",
    "gold_sql": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` + T2.`Enrollment (Ages 5-17)` > 500",
    "predicted_sql": "SELECT \n  frpm.cdscode \nFROM \n  california_schools.frpm \nWHERE \n  (frpm.enrollment(k-12) + frpm.enrollment(ages 5-17)) > 500",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"(\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 12,
    "db_id": "california_schools",
    "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
    "evidence": "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
    "gold_sql": "SELECT MAX(CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
    "predicted_sql": "SELECT \n    satscores.avgscrread AS highest_eligible_free_rate\nFROM \n    satscores\nJOIN \n    frpm ON satscores.cds = frpm.cdscode\nWHERE \n    satscores.avgscrread / satscores.numtsttakr > 0.3\nORDER BY \n    satscores.avgscrread / satscores.numtsttakr DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 13,
    "db_id": "california_schools",
    "question": "Please list the phone numbers of the schools with the top 3 SAT excellence rate.",
    "evidence": "Excellence rate = NumGE1500 / NumTstTakr",
    "gold_sql": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC LIMIT 3",
    "predicted_sql": "SELECT \n    s.phone \nFROM \n    schools s \nJOIN \n    satscores ss ON s.cdscode = ss.cds \nORDER BY \n    ss.numge1500 / ss.numtsttakr DESC \nLIMIT \n    3",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 14,
    "db_id": "california_schools",
    "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
    "evidence": "",
    "gold_sql": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
    "predicted_sql": "SELECT \n    s.cdscode AS 'NCES School Identification Number', \n    COUNT(f.enrollment) AS 'Enrollment (Ages 5-17)'\nFROM \n    frpm f\nJOIN \n    schools s ON f.cdscode = s.cdscode\nWHERE \n    f.enrollment > 0\nGROUP BY \n    s.cdscode\nORDER BY \n    COUNT(f.enrollment) DESC\nLIMIT 5",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.enrollment",
    "difficulty": "simple"
  },
  {
    "idx": 15,
    "db_id": "california_schools",
    "question": "Which active district has the highest average score in Reading?",
    "evidence": "",
    "gold_sql": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
    "predicted_sql": "SELECT \n  dname\nFROM \n  satscores\nWHERE \n  statustype = 'Active'\n  AND rtype = 'Reading'\nORDER BY \n  avgscrread DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: statustype",
    "difficulty": "simple"
  },
  {
    "idx": 16,
    "db_id": "california_schools",
    "question": "How many schools in merged Alameda have number of test takers less than 100?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(T1.CDSCode) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Merged' AND T2.NumTstTakr < 100 AND T1.County = 'Lake'",
    "predicted_sql": "SELECT COUNT(*)\nFROM satscores\nWHERE enroll12 < 100 AND\n      (sname LIKE '%Alameda%' OR dname LIKE '%Alameda%' OR cname LIKE '%Alameda%')",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 17,
    "db_id": "california_schools",
    "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
    "evidence": "Valid charter number means the number is not null",
    "gold_sql": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
    "predicted_sql": "SELECT \n  s.sname, \n  s.cname, \n  s.dname, \n  AVG(s.avgscrw) AS avg_score\nFROM \n  satscores s\nWHERE \n  s.avgscrw > 499\n  AND s.charter IS NOT NULL\nGROUP BY \n  s.sname, \n  s.cname, \n  s.dname\nORDER BY \n  avg_score DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.avgscrw",
    "difficulty": "simple"
  },
  {
    "idx": 18,
    "db_id": "california_schools",
    "question": "How many schools in Fresno (directly funded) have number of test takers not more than 250?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(T1.CDSCode) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`County Name` = 'Fresno' AND T2.NumTstTakr <= 250",
    "predicted_sql": "SELECT COUNT(*)\nFROM satscores\nWHERE rtype = 'D' AND numtsttakr <= 250",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 19,
    "db_id": "california_schools",
    "question": "What is the phone number of the school that has the highest average score in Math?",
    "evidence": "",
    "gold_sql": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.AvgScrMath DESC LIMIT 1",
    "predicted_sql": "SELECT s.phone\nFROM schools s\nJOIN satscores sc ON s.cdscode = sc.cds\nORDER BY sc.avgscrmath DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 20,
    "db_id": "california_schools",
    "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
    "predicted_sql": "SELECT COUNT(DISTINCT s.cdscode)\nFROM schools s\nJOIN frpm f ON s.cdscode = f.cdscode\nWHERE f.county_name = 'Amador'\nAND f.low_grade = 9\nAND f.high_grade = 12",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.county_name",
    "difficulty": "simple"
  },
  {
    "idx": 21,
    "db_id": "california_schools",
    "question": "In Los Angeles how many schools have more than 500 free meals but less than 700 free or reduced price meals for K-12?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)`< 700",
    "predicted_sql": "SELECT COUNT(*)\nFROM california_schools.frpm\nWHERE county_code = '037' AND\n      (free_meal_count(k-12) BETWEEN 500 AND 700) OR\n      (frpm_count(k-12) BETWEEN 500 AND 700)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "simple"
  },
  {
    "idx": 22,
    "db_id": "california_schools",
    "question": "Which school in Contra Costa has the highest number of test takers?",
    "evidence": "",
    "gold_sql": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
    "predicted_sql": "SELECT s.sname, s.cname, COUNT(sats.numtsttakr) AS num_test_takers\nFROM satscores sats\nJOIN schools s ON sats.cds = s.cdscode\nWHERE s.county = 'Contra Costa'\nGROUP BY s.sname, s.cname\nORDER BY num_test_takers DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.sname",
    "difficulty": "simple"
  },
  {
    "idx": 23,
    "db_id": "california_schools",
    "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
    "evidence": "Diffrence in enrollement = `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
    "gold_sql": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
    "predicted_sql": "SELECT \n    s.school, \n    s.street, \n    s.streetabr, \n    s.city, \n    s.zip, \n    s.state, \n    frpm.enrollment_k12 - frpm.enrollment_ages517 AS diff\nFROM \n    california_schools.frpm AS frpm\nJOIN \n    california_schools.schools AS s\nON \n    frpm.cdscode = s.cdscode\nWHERE \n    frpm.enrollment_k12 - frpm.enrollment_ages517 > 30",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 24,
    "db_id": "california_schools",
    "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
    "evidence": "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)",
    "gold_sql": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
    "predicted_sql": "SELECT \n  sname, \n  dname, \n  cname, \n  (frpm_count / enrollment) * 100 AS percent_eligible_free_meals\nFROM \n  california_schools.frpm\n  JOIN california_schools.satscores\n  ON frpm.cdscode = satscores.cds\nWHERE \n  (frpm_count / enrollment) * 100 > 0.1 \n  AND satscores.avgscrread >= 1500\nORDER BY \n  percent_eligible_free_meals DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 25,
    "db_id": "california_schools",
    "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
    "evidence": "Average of average math = sum(average math scores) / count(schools).",
    "gold_sql": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
    "predicted_sql": "SELECT s.fundingtype\nFROM schools s\nJOIN satscores sc ON s.cdscode = sc.cds\nWHERE sc.avgscrmath > 400 AND s.county = 'Riverside'\nGROUP BY s.fundingtype",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 26,
    "db_id": "california_schools",
    "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
    "evidence": "Full communication address should include Street, City, State and zip code if any.",
    "gold_sql": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
    "predicted_sql": "SELECT \n    s.school_name,\n    s.street,\n    s.street_abr,\n    s.city,\n    s.zip,\n    s.state\nFROM \n    california_schools.frpm AS frpm\n    JOIN california_schools.schools AS s ON frpm.cds_code = s.cds_code\nWHERE \n    frpm.county_code = '06037' \n    AND frpm.low_grade = '09' \n    AND frpm.high_grade = '12' \n    AND frpm.enrollment_ages_517 > 800 \n    AND frpm.percent_eligible_free_ages_517 > 0 \n    AND frpm.percent_eligible_frpm_ages_517 > 0",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 27,
    "db_id": "california_schools",
    "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
    "evidence": "Communication number refers to phone number.",
    "gold_sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
    "predicted_sql": "SELECT \n  sname, \n  avgscrwrite, \n  phone \nFROM \n  satscores \n  INNER JOIN \n    schools \n  ON \n    satscores.cds = schools.cdscode \nWHERE \n  schools.opendate > '1991-01-01' \n  OR \n  schools.closeddate < '2000-01-01'\nGROUP BY \n  sname, \n  avgscrwrite, \n  phone",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 28,
    "db_id": "california_schools",
    "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
    "evidence": "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
    "gold_sql": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
    "predicted_sql": "SELECT s.name, s.doc\nFROM schools s\nJOIN frpm f ON s.cdscode = f.cdscode\nWHERE f.district_type = 'Locally Funded'\nAND f.enrollment_k12 - f.enrollment_ages517 > (\n  SELECT AVG(f.enrollment_k12 - f.enrollment_ages517) \n  FROM frpm f\n  WHERE f.district_type = 'Locally Funded'\n)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.name",
    "difficulty": "challenging"
  },
  {
    "idx": 29,
    "db_id": "california_schools",
    "question": "When did the first-through-twelfth-grade school with the largest enrollment open?",
    "evidence": "K-12 means First-through-twelfth-grade",
    "gold_sql": "SELECT T2.OpenDate FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
    "predicted_sql": "SELECT \n    s.opendate \nFROM \n    schools s \nWHERE \n    s.statustype = 'Public' \n    AND s.grade_level = 'K-12' \n    AND s.enrollment = (SELECT MAX(enrollment) FROM schools s2 WHERE s2.statustype = 'Public' AND s2.grade_level = 'K-12')",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.grade_level",
    "difficulty": "simple"
  },
  {
    "idx": 30,
    "db_id": "california_schools",
    "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
    "evidence": "K-12 refers to students in grades 1 through 12.",
    "gold_sql": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
    "predicted_sql": "SELECT \n    s.city, \n    COUNT(s.cdscod) AS enrollment\nFROM \n    california_schools.satscores s\nWHERE \n    s.enroll12 > 0\nGROUP BY \n    s.city\nORDER BY \n    enrollment ASC\nLIMIT 5",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.satscores",
    "difficulty": "simple"
  },
  {
    "idx": 31,
    "db_id": "california_schools",
    "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
    "evidence": "K-12 refers to students in grades 1 through 12; Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`",
    "gold_sql": "SELECT CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)` FROM frpm ORDER BY `Enrollment (K-12)` DESC LIMIT 9, 2",
    "predicted_sql": "SELECT \n    s.cdscode, \n    s.school, \n    COUNT(f.enrollment) AS enrollment\n  FROM \n    schools s\n  JOIN \n    frpm f ON s.cdscode = f.cdscode\n  WHERE \n    f.low_grade = '1' AND f.high_grade = '12'\n  GROUP BY \n    s.cdscode, s.school\n  ORDER BY \n    enrollment DESC\n  LIMIT 10\n)\nSELECT \n  e.cdscode, \n  e.school, \n  f.percent_free_meal_count_k_12 / f.enrollment_k_12 AS eligible_free_rate\nFROM \n  enrollment_rank e\n  JOIN \n  frpm f ON e.cdscode = f.cdscode\nWHERE \n  e.cdscode IN (SELECT cdscode FROM enrollment_rank ORDER BY enrollment DESC OFFSET 9 ROWS FETCH NEXT 2 ROWS ONLY)\nORDER BY \n  eligible_free_rate",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \")\": syntax error",
    "difficulty": "moderate"
  },
  {
    "idx": 32,
    "db_id": "california_schools",
    "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
    "evidence": "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`",
    "gold_sql": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
    "predicted_sql": "SELECT \n  s.name AS school_name,\n  ROUND(FRPM_COUNT.K12 / ENROLLMENT.K12, 2) AS eligible_free_reduced_price_meal_rate\nFROM \n  california_schools.frpm FRPM_COUNT\n  INNER JOIN california_schools.schools S ON FRPM_COUNT.cdscode = S.cdscode\nWHERE \n  S.edopscode = '66'\n  AND FRPM_COUNT.k12 > 0\nORDER BY \n  FRPM_COUNT.k12 DESC\nLIMIT 5",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 33,
    "db_id": "california_schools",
    "question": "If there are any, what are the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17? Include the name of the school.",
    "evidence": "",
    "gold_sql": "SELECT T2.Website, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000 AND T2.Website IS NOT NULL",
    "predicted_sql": "SELECT s.school, s.website\nFROM california_schools.frpm AS frpm\nJOIN california_schools.schools AS s ON frpm.cdscode = s.cdscode\nWHERE frpm.enrollment_ages_517 >= 1900 AND frpm.enrollment_ages_517 <= 2000",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 34,
    "db_id": "california_schools",
    "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
    "evidence": "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
    "gold_sql": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
    "predicted_sql": "SELECT \n  frpm.frpm_count_ages_5_17 AS frpm_count, \n  frpm.enrollment_ages_5_17 AS enrollment, \n  ROUND(frpm.frpm_count_ages_5_17 / frpm.enrollment_ages_5_17, 2) AS eligible_free_rate\nFROM \n  california_schools.frpm \n  JOIN california_schools.schools \n  ON frpm.cdscode = schools.cdscode \nWHERE \n  schools.admfname1 = 'Kacey' \n  AND schools.admlname1 = 'Gibson'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 35,
    "db_id": "california_schools",
    "question": "What is the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12?",
    "evidence": "Charted school means `Charter School (Y/N)` = 1 in the table frpm; Students enrolled in grades 1 through 12 refers to `Enrollment (K-12)`",
    "gold_sql": "SELECT T2.AdmEmail1 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter School (Y/N)` = 1 ORDER BY T1.`Enrollment (K-12)` ASC LIMIT 1",
    "predicted_sql": "SELECT \n  s.admemail1 AS admin_email\nFROM \n  frpm f\n  JOIN schools s ON f.cdscode = s.cdscode\nWHERE \n  f.charter_school = '1' AND\n  f.enrollment_k_12 = (SELECT MIN(enrollment_k_12) FROM frpm)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.charter_school",
    "difficulty": "moderate"
  },
  {
    "idx": 36,
    "db_id": "california_schools",
    "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
    "evidence": "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
    "gold_sql": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.admfname1, s.admlname1, s.admemail1 AS full_name\nFROM \n  schools s\n  JOIN frpm f ON s.cdscode = f.cdscode\n  JOIN satscores ss ON s.cdscode = ss.cds\nWHERE \n  ss.numge1500 > 0\nORDER BY \n  f.enrollment (k-12) DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"(\": syntax error",
    "difficulty": "challenging"
  },
  {
    "idx": 37,
    "db_id": "california_schools",
    "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
    "evidence": "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code",
    "gold_sql": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
    "predicted_sql": "SELECT \n  s.street, \n  s.city, \n  s.state, \n  s.zip \nFROM \n  schools s \nWHERE \n  s.cdscode IN (SELECT \n                  satscores.cds \n                FROM \n                  satscores \n                ORDER BY \n                  satscores.avgscrread / satscores.numtsttakr \n                LIMIT 1)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 38,
    "db_id": "california_schools",
    "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
    "evidence": "",
    "gold_sql": "SELECT T2.Website FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr BETWEEN 2000 AND 3000 AND T2.County = 'Los Angeles'",
    "predicted_sql": "SELECT s.website\nFROM schools s\nJOIN satscores sc ON s.cdscode = sc.cds\nWHERE s.county = 'Los Angeles'\nAND sc.numtsttakr BETWEEN 2000 AND 3000",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 39,
    "db_id": "california_schools",
    "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
    "evidence": "between 1/1/1980 and 12/31/1980 means the year = 1980",
    "gold_sql": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
    "predicted_sql": "SELECT AVG(numtsttakr) AS average_test_takers\nFROM satscores\nJOIN schools ON satscores.cds = schools.cdscode\nWHERE county = 'Fresno' AND opendate BETWEEN '1980-01-01' AND '1980-12-31'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 40,
    "db_id": "california_schools",
    "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
    "evidence": "Fresno Unified is a name of district;",
    "gold_sql": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
    "predicted_sql": "SELECT phone\nFROM schools\nJOIN satscores ON schools.cdscode = satscores.cds\nWHERE district = 'Fresno Unified'\nORDER BY avgscrread ASC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 41,
    "db_id": "california_schools",
    "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
    "evidence": "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County",
    "gold_sql": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
    "predicted_sql": "SELECT \n  s.name, \n  s.county, \n  AVG(s.avgscrread) AS avg_reading_score\nFROM \n  satscores s\n  JOIN schools sch ON s.cds = sch.cdscode\nWHERE \n  s.rtype = 'F'  -- Exclusively virtual\n  AND sch.charter = 'Y'  -- Virtual school\n  AND s.enroll12 > 0  -- Not empty school\nGROUP BY \n  s.county, \n  s.name\nORDER BY \n  AVG(s.avgscrread) DESC\nLIMIT 5",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.name",
    "difficulty": "simple"
  },
  {
    "idx": 42,
    "db_id": "california_schools",
    "question": "What is the type of education offered in the school who scored the highest average in Math?",
    "evidence": "",
    "gold_sql": "SELECT T2.EdOpsName FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.sname, \n  s.dname, \n  s.cname, \n  ss.avgscrmath\nFROM \n  schools s \n  JOIN satscores ss ON s.cdscode = ss.cds\nORDER BY \n  ss.avgscrmath DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.sname",
    "difficulty": "simple"
  },
  {
    "idx": 43,
    "db_id": "california_schools",
    "question": "What is the average math score of the school with the lowest average score for all subjects, and in which county is it located?",
    "evidence": "Average score for all subjects can be computed by AvgScrMath + AvgScrRead + AvgScrWrite",
    "gold_sql": "SELECT T1.AvgScrMath, T2.County FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath IS NOT NULL ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC LIMIT 1",
    "predicted_sql": "SELECT \n    s.name, \n    s.county, \n    AVG(s.AvgScrMath + s.AvgScrRead + s.AvgScrWrite) AS average_score\nFROM \n    satscores s\nJOIN \n    schools s2 ON s.cds = s2.cdscode\nORDER BY \n    average_score ASC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.name",
    "difficulty": "moderate"
  },
  {
    "idx": 44,
    "db_id": "california_schools",
    "question": "What is the average writing score of the school who has the highest number of test takers whose total SAT sscores are greater or equal to 1500? Indicate the city to where the school is situated.",
    "evidence": "",
    "gold_sql": "SELECT T1.AvgScrWrite, T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
    "predicted_sql": "SELECT \n    s.sname, \n    s.city, \n    AVG(s.avgscrwrit) AS avg_writing_score\nFROM \n    satscores s\nJOIN \n    schools sch ON s.cds = sch.cdscode\nWHERE \n    s.numge1500 > 0\nGROUP BY \n    s.sname, s.city\nORDER BY \n    COUNT(s.numtsttakr) DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.city",
    "difficulty": "simple"
  },
  {
    "idx": 45,
    "db_id": "california_schools",
    "question": "What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.",
    "evidence": "Usually, administrators manage the school stuff.",
    "gold_sql": "SELECT T2.School, T1.AvgScrWrite FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'",
    "predicted_sql": "SELECT \n  s.name, \n  AVG(satscores.avgscrwrit) AS avg_writing_score\nFROM \n  schools s\n  JOIN satscores ON s.cdscode = satscores.cds\n  JOIN frpm ON s.cdscode = frpm.cdscode\nWHERE \n  s.statustype = 'Active' \n  AND s.charter = 'N' \n  AND frpm.charter_school = 'N' \n  AND sadmfname1 = 'Ricci' \n  AND sadmlname1 = 'Ulrich'\nGROUP BY \n  s.name\nORDER BY \n  avg_writing_score DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.name",
    "difficulty": "moderate"
  },
  {
    "idx": 46,
    "db_id": "california_schools",
    "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
    "evidence": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
    "gold_sql": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
    "predicted_sql": "SELECT \n    s.school_name, \n    COUNT(f.cdscode) AS enrollment_count \nFROM \n    schools s \nJOIN \n    frpm f ON s.cdscode = f.cdscode \nWHERE \n    s.statustype = 31 \n    AND f.low_grade = '1' \n    AND f.high_grade = '12' \nGROUP BY \n    s.school_name \nORDER BY \n    enrollment_count DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.school_name",
    "difficulty": "simple"
  },
  {
    "idx": 47,
    "db_id": "california_schools",
    "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
    "evidence": "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12",
    "gold_sql": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
    "predicted_sql": "SELECT \n    COUNT(DISTINCT s.cdscode) AS monthly_average_number_of_schools\nFROM \n    schools s\nWHERE \n    s.county = 'Alameda'\n    AND s.statustype = 'Elementary School District'\n    AND s.opendate >= '1980-01-01'\n    AND s.opendate < '1981-01-01'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 48,
    "db_id": "california_schools",
    "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
    "evidence": "Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54.",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
    "predicted_sql": "SELECT \n  COUNT(DISTINCT s1.cdscode) AS merged_unified_sds, \n  COUNT(DISTINCT s2.cdscode) AS merged_elementary_sds\nFROM \n  schools s1\n  JOIN schools s2 ON s1.cdscode = s2.cdscode\nWHERE \n  s1.doc = 54 AND s1.county = 'Orange' AND s2.doc = 52 AND s2.county = 'Orange'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 49,
    "db_id": "california_schools",
    "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
    "evidence": "Closure date and closed date are synonyms; 'Closed' was mentioned in schools.StatusType.",
    "gold_sql": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
    "predicted_sql": "SELECT \n  s.county, \n  s.school, \n  s.closeddate\nFROM \n  schools s\nWHERE \n  s.statustype = 'Closed'\nGROUP BY \n  s.county, \n  s.school\nORDER BY \n  COUNT(s.county) DESC",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 50,
    "db_id": "california_schools",
    "question": "What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.",
    "evidence": "Postal street and mailing street are synonyms.",
    "gold_sql": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1",
    "predicted_sql": "SELECT s.street, s.school\nFROM satscores s\nJOIN schools sch ON s.cds = sch.cdscode\nORDER BY s.avgscrmath DESC\nLIMIT 7 OFFSET 0",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.street",
    "difficulty": "simple"
  },
  {
    "idx": 51,
    "db_id": "california_schools",
    "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
    "evidence": "",
    "gold_sql": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
    "predicted_sql": "SELECT s.streetabr AS Mailing_Street_Address, s.sname AS School_Name\nFROM schools s\nJOIN satscores sc ON s.cdscode = sc.cds\nWHERE sc.rtype = 'R' AND sc.avgscrread = (SELECT MIN(avgscrread) FROM satscores)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.sname",
    "difficulty": "simple"
  },
  {
    "idx": 52,
    "db_id": "california_schools",
    "question": "What is the total number of schools whose total SAT scores are greater or equal to 1500 whose mailing city is Lakeport?",
    "evidence": "Total SAT scores can be computed by AvgScrRead + AvgScrMath + AvgScrWrite",
    "gold_sql": "SELECT COUNT(T1.cds) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Lakeport' AND (T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite) >= 1500",
    "predicted_sql": "SELECT COUNT(*)\nFROM schools s\nJOIN satscores sc ON s.cdscode = sc.cds\nWHERE sc.numtsttakr > 0 AND sc.avgscrread + sc.avgscrmath + sc.avgscrwrite >= 1500 AND s.mailcity = 'Lakeport'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 53,
    "db_id": "california_schools",
    "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
    "evidence": "",
    "gold_sql": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
    "predicted_sql": "SELECT \n  COUNT(satscores.numtsttakr) \nFROM \n  satscores \nJOIN \n  schools ON satscores.cds = schools.cdscode \nWHERE \n  schools.mailcity LIKE '%Fresno%'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 54,
    "db_id": "california_schools",
    "question": "Please specify all of the schools and their related mailing zip codes that are under Avetik Atoian's administration.",
    "evidence": "",
    "gold_sql": "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian'",
    "predicted_sql": "SELECT \n  s.cdscode, \n  s.school, \n  s.mailzip\nFROM \n  schools s\nWHERE \n  s.admfname1 = 'Avetik Atoian'\n  OR s.admfname2 = 'Avetik Atoian'\n  OR s.admfname3 = 'Avetik Atoian'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 55,
    "db_id": "california_schools",
    "question": "Of the schools with a mailing state address in California, what is the ratio of the schools located in the county of Colusa against the school located in the county of Humboldt?",
    "evidence": "Ratio = count(schools in Colusa) / count(schools in Humboldt)",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) FROM schools WHERE MailState = 'CA'",
    "predicted_sql": "SELECT \n  COUNT(CASE WHEN state = 'CA' AND county = 'Colusa' THEN 1 ELSE NULL END) AS Colusa_Schools,\n  COUNT(CASE WHEN state = 'CA' AND county = 'Humboldt' THEN 1 ELSE NULL END) AS Humboldt_Schools,\n  (COUNT(CASE WHEN state = 'CA' AND county = 'Colusa' THEN 1 ELSE NULL END) / \n   COUNT(CASE WHEN state = 'CA' AND county = 'Humboldt' THEN 1 ELSE NULL END)) AS Ratio\nFROM \n  schools\nWHERE \n  state = 'CA'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 56,
    "db_id": "california_schools",
    "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
    "predicted_sql": "SELECT COUNT(*)\nFROM schools\nWHERE state = 'CA' AND city = 'San Joaquin' AND statustype = 'Active'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 57,
    "db_id": "california_schools",
    "question": "What is the phone number and extension number for the school that had the 333rd highest average writing score?",
    "evidence": "",
    "gold_sql": "SELECT T2.Phone, T2.Ext FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrWrite DESC LIMIT 332, 1",
    "predicted_sql": "SELECT s.phone, s.ext\nFROM satscores s\nJOIN schools sch ON s.cds = sch.cdscode\nORDER BY s.avgscrwrite DESC\nLIMIT 333, 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.phone",
    "difficulty": "simple"
  },
  {
    "idx": 58,
    "db_id": "california_schools",
    "question": "What is the phone number and extension number for the school with the zip code 95203-3704? Indicate the school's name.",
    "evidence": "",
    "gold_sql": "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'",
    "predicted_sql": "SELECT s.phone, s.ext, s.school\nFROM schools s\nWHERE s.zip = '95203-3704'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 59,
    "db_id": "california_schools",
    "question": "What is the website for the schools under the administrations of Mike Larson and Dante Alvarez?",
    "evidence": "",
    "gold_sql": "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez')",
    "predicted_sql": "SELECT \n    s.website\nFROM \n    schools s\nWHERE \n    s.admfname1 = 'Mike Larson' OR s.admfname2 = 'Mike Larson' OR s.admfname3 = 'Mike Larson'\n    OR s.admfname1 = 'Dante Alvarez' OR s.admfname2 = 'Dante Alvarez' OR s.admfname3 = 'Dante Alvarez'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 60,
    "db_id": "california_schools",
    "question": "What are the websites for all the partially virtual chartered schools located in San Joaquin?",
    "evidence": "Virtual = 'P' means partially virtual; Charter schools refers to Charter = 1 in the table schools",
    "gold_sql": "SELECT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1",
    "predicted_sql": "SELECT s.website\nFROM schools s\nWHERE s.charter = 1 AND s.virtual = 'P' AND s.county = 'San Joaquin'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 61,
    "db_id": "california_schools",
    "question": "How many chartered schools located in the city of Hickman are owned by the Elementary School District?",
    "evidence": "Elementary School District refers to DOC = 52; Chartered schools refer to Charter = 1 in the table schools",
    "gold_sql": "SELECT COUNT(School) FROM schools WHERE DOC = 52 AND Charter = 1 AND City = 'Hickman'",
    "predicted_sql": "SELECT COUNT(DISTINCT s.cdscode) \nFROM schools s \nWHERE s.charter = 1 \nAND s.city = 'Hickman' \nAND s.doc = 52",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 62,
    "db_id": "california_schools",
    "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
    "evidence": "non-chartered schools refer to schools whose Charter = 0; K-12 means grades 1 through 12; percent of eligible free rate for K-12 = `Free Meal Count (K-12)` * 100 / `Enrollment (K-12)`",
    "gold_sql": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18",
    "predicted_sql": "SELECT COUNT(*)\nFROM frpm\nWHERE county code = 'Los Angeles' AND charter school = 'N' AND percent (%) eligible free (k-12) < 0.18",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"code\": syntax error",
    "difficulty": "challenging"
  },
  {
    "idx": 63,
    "db_id": "california_schools",
    "question": "In chartered schools with charter number 00D2, what are the names of all the administrators? Include the name of the school and the city to which it belongs",
    "evidence": "Chartered schools refer to Charter = 1 in the table schools; Full name refers to first name, last name",
    "gold_sql": "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'",
    "predicted_sql": "SELECT \n    s.school, \n    s.city, \n    s.admfname1, \n    s.admlname1, \n    s.admemail1, \n    s.admfname2, \n    s.admlname2, \n    s.admemail2, \n    s.admfname3, \n    s.admlname3, \n    s.admemail3\nFROM \n    schools s\nWHERE \n    s.charter = 1 AND \n    s.charternum = '00D2'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 64,
    "db_id": "california_schools",
    "question": "What is the total number of schools with a mailing city in Hickman belonging to the charter number 00D4?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(*) FROM schools WHERE CharterNum = '00D4' AND MailCity = 'Hickman'",
    "predicted_sql": "SELECT COUNT(DISTINCT s.cdscode) \nFROM schools s \nWHERE s.mailcity = 'Hickman' \nAND s.charter = 'Y' \nAND s.charternum = '00D4'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 65,
    "db_id": "california_schools",
    "question": "What is the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding?",
    "evidence": "Ratio in percentage = (count(locally funded schools in Santa Clara) / count(all funding type schools in Santa Clara) * 100%",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) FROM schools WHERE County = 'Santa Clara' AND Charter = 1",
    "predicted_sql": "SELECT \n  ROUND((COUNT(DISTINCT s.cdscode) \n  WHERE s.county = 'Santa Clara' AND s.fundingtype = 'locally funded') \n  / (SELECT COUNT(DISTINCT s.cdscode) \n  FROM schools s \n  WHERE s.county = 'Santa Clara') * 100, 2) AS locally_funded_ratio\nFROM \n  schools s\nWHERE \n  s.county = 'Santa Clara'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"WHERE\": syntax error",
    "difficulty": "moderate"
  },
  {
    "idx": 66,
    "db_id": "california_schools",
    "question": "Between 1/1/2000 to 12/31/2005, how many directly funded schools opened in the county of Stanislaus?",
    "evidence": "Directly funded schools refers to FundingType = 'Directly Funded'",
    "gold_sql": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded'",
    "predicted_sql": "SELECT COUNT(DISTINCT s.cdscode)\nFROM schools s\nWHERE s.opendate BETWEEN '2000-01-01' AND '2005-12-31'\nAND s.county = 'Stanislaus'\nAND s.fundingtype = 'Directly Funded'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 67,
    "db_id": "california_schools",
    "question": "What is the total amount of Community College District closure in 1989 in the city of San Francisco?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'",
    "predicted_sql": "SELECT SUM(schools.cdscode) AS Total_Closure\nFROM schools\nWHERE schools.city = 'San Francisco' AND schools.statustype = 'Closed' AND schools.opendate <= '1989-01-01' AND schools.closeddate >= '1989-01-01'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 68,
    "db_id": "california_schools",
    "question": "Which county reported the most number of school closure in the 1980s with school wonership code belonging to Youth Authority Facilities (CEA)?",
    "evidence": "Youth Authority Facilities (CEA) refers to SOC = 11; 1980s = years between 1980 and 1989",
    "gold_sql": "SELECT County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND StatusType = 'Closed' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.county, \n  COUNT(s.school) AS total_closures\nFROM \n  schools s\n  JOIN frpm f ON s.cdscode = f.cdscode\nWHERE \n  s.statustype = 'Closed'\n  AND s.opendate < '1980-01-01'\n  AND s.closeddate >= '1989-12-31'\n  AND s.soc = 11\nGROUP BY \n  s.county\nORDER BY \n  total_closures DESC",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 69,
    "db_id": "california_schools",
    "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
    "evidence": "State Special Schools means that SOC = 31.",
    "gold_sql": "SELECT NCESDist FROM schools WHERE SOC = 31",
    "predicted_sql": "SELECT \n    s.ncesschool \nFROM \n    schools s \nWHERE \n    s.soc = 31",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 70,
    "db_id": "california_schools",
    "question": "How many active and closed District Community Day Schools are there in the county of Alpine?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'",
    "predicted_sql": "SELECT COUNT(DISTINCT s.cdscode) \nFROM schools s \nJOIN frpm f ON s.cdscode = f.cdscode \nWHERE s.statustype = 'Active' OR s.statustype = 'Closed' \nAND s.county = 'Alpine' \nAND s.schooltype = 'District Community Day School'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.schooltype",
    "difficulty": "simple"
  },
  {
    "idx": 71,
    "db_id": "california_schools",
    "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
    "evidence": "When magent is equal to 0 in the database, it means ths school doesn't offer a magnet program.",
    "gold_sql": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
    "predicted_sql": "SELECT d.district_code\nFROM schools s\nJOIN districts d ON s.district = d.district\nWHERE s.city = 'Fresno' AND s.magnet = 0",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: districts",
    "difficulty": "simple"
  },
  {
    "idx": 72,
    "db_id": "california_schools",
    "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
    "evidence": "State Special School means EdOpsCode = 'SSS'",
    "gold_sql": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
    "predicted_sql": "SELECT \n  COUNT(satscores.enroll12) \nFROM \n  satscores \nWHERE \n  satscores.cds = \n    (SELECT \n       frpm.cdscode \n     FROM \n       frpm \n     WHERE \n       frpm.academic_year = 2014 \n       AND frpm.county_code = '031' \n       AND frpm.district_code = '' \n       AND frpm.school_code = '' \n       AND frpm.educational_option_type = 'SSS' \n       AND frpm.charter_school = 'N') \n  AND satscores.enroll12 BETWEEN 5 AND 17",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: frpm.academic_year",
    "difficulty": "moderate"
  },
  {
    "idx": 73,
    "db_id": "california_schools",
    "question": "What is the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040?",
    "evidence": "",
    "gold_sql": "SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.MailStreet = 'PO Box 1040' AND T2.SOCType = 'Youth Authority Facilities'",
    "predicted_sql": "SELECT \n  frpm.frpm_count_ages_5_17 AS free_or_reduced_price_meal_count\nFROM \n  california_schools.frpm\n  JOIN california_schools.schools ON frpm.cdscode = schools.cdscode\nWHERE \n  schools.school = 'Youth Authority School'\n  AND schools.mailstreet = 'PO Box 1040'\n  AND frpm.enrollment_ages_5_17 > 0",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "simple"
  },
  {
    "idx": 74,
    "db_id": "california_schools",
    "question": "What is the lowest grade for the District Special Education Consortia School with National Center for Educational Statistics school district identification number of 0613360?",
    "evidence": "District Special Education Consortia School refers to EdOpsCode = 'SPECON'.",
    "gold_sql": "SELECT MIN(T1.`Low Grade`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.NCESDist = '0613360' AND T2.EdOpsCode = 'SPECON'",
    "predicted_sql": "SELECT \n    low_grade \nFROM \n    frpm \nWHERE \n    district_type = 'SPECON' \n    AND ncesdist = '0613360'\nORDER BY \n    low_grade ASC \nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: low_grade",
    "difficulty": "moderate"
  },
  {
    "idx": 75,
    "db_id": "california_schools",
    "question": "What is the educational level name for the schools with Breakfast Provision 2 in county code 37? Indicate the name of the school.",
    "evidence": "",
    "gold_sql": "SELECT T2.EILName, T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = 37",
    "predicted_sql": "SELECT \n    s.name, \n    e.educational_level_name\nFROM \n    schools s\nJOIN \n    frpm f ON s.cdscode = f.cdscode\nJOIN \n    educational_options e ON f.educational_option_type = e.educational_option_type\nWHERE \n    f.county_code = 37 \n    AND f.breakfast_provision_status = '2'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: educational_options",
    "difficulty": "simple"
  },
  {
    "idx": 76,
    "db_id": "california_schools",
    "question": "What is the city location of the high school level school with Lunch Provision 2 whose lowest grade is 9 and the highest grade is 12 in the county of Merced?",
    "evidence": "High school can be represented as EILCode = 'HS'",
    "gold_sql": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Lunch Provision 2' AND T2.County = 'Merced' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12 AND T2.EILCode = 'HS'",
    "predicted_sql": "SELECT s.city\nFROM schools s\nJOIN frpm f ON s.cdscode = f.school code\nWHERE f.county code = '015' AND f.low grade = '9' AND f.high grade = '12' AND f.frpm provision status = '2' AND f.school type = 'HS'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"code\": syntax error",
    "difficulty": "moderate"
  },
  {
    "idx": 77,
    "db_id": "california_schools",
    "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
    "evidence": "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by `FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100",
    "gold_sql": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
    "predicted_sql": "SELECT \n    s.school_name, \n    frpm.percent_eligible_frpm_ages_517 AS percent_eligible_frpm_ages_517\nFROM \n    california_schools.frpm \n    JOIN california_schools.schools s ON frpm.cdscode = s.cdscode\nWHERE \n    frpm.county_name = 'Los Angeles' \n    AND frpm.low_grade = 'K' \n    AND frpm.high_grade = '9'\nORDER BY \n    percent_eligible_frpm_ages_517 DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "moderate"
  },
  {
    "idx": 78,
    "db_id": "california_schools",
    "question": "What is the most common type of grade span served in the city of Adelanto?",
    "evidence": "",
    "gold_sql": "SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.school_name, \n  COUNT(s.school_name) AS num_schools, \n  COUNT(DISTINCT s.low_grade) AS num_grade_spans\nFROM \n  california_schools.frpm s\nWHERE \n  s.county_name = 'Adelanto'\nGROUP BY \n  s.school_name\nORDER BY \n  num_grade_spans DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: california_schools.frpm",
    "difficulty": "simple"
  },
  {
    "idx": 79,
    "db_id": "california_schools",
    "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
    "evidence": "'Does not offer physical building' means Virtual = F in the database.",
    "gold_sql": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
    "predicted_sql": "SELECT \n    c.name AS county_name, \n    COUNT(s.cdscode) AS num_schools\nFROM \n    schools s \nJOIN \n    frpm f ON s.cdscode = f.cdscode \nWHERE \n    f.virtual = 'F' \n    AND s.county IN (SELECT county FROM schools WHERE city IN ('San Diego', 'Santa Barbara')) \nGROUP BY \n    c.name \nORDER BY \n    num_schools DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: c.name",
    "difficulty": "moderate"
  },
  {
    "idx": 80,
    "db_id": "california_schools",
    "question": "What is the school type of the school with the highest latitude? Indicate the name of the school as well as the latitude coordinates.",
    "evidence": "",
    "gold_sql": "SELECT T1.`School Type`, T1.`School Name`, T2.Latitude FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.Latitude DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.school, \n  s.latitude, \n  s.school_type\nFROM \n  schools s\nORDER BY \n  s.latitude DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.school_type",
    "difficulty": "simple"
  },
  {
    "idx": 81,
    "db_id": "california_schools",
    "question": "In which city can you find the school in the state of California with the lowest latitude coordinates and what is its lowest grade? Indicate the school name.",
    "evidence": "State of California refers to state = 'CA'",
    "gold_sql": "SELECT T2.City, T1.`Low Grade`, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.State = 'CA' ORDER BY T2.Latitude ASC LIMIT 1",
    "predicted_sql": "SELECT \n  s.city, \n  s.school, \n  s.low_grade \nFROM \n  schools s \nWHERE \n  s.state = 'CA' \n  AND s.latitude = (SELECT MIN(latitude) FROM schools s2 WHERE s2.state = 'CA') \n  AND s.low_grade IS NOT NULL \n  AND s.low_grade!= '' \nORDER BY \n  s.low_grade",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.low_grade",
    "difficulty": "moderate"
  },
  {
    "idx": 82,
    "db_id": "california_schools",
    "question": "What is the grade span offered in the school with the highest longitude?",
    "evidence": "the highest longitude refers to the school with the maximum absolute longitude value.",
    "gold_sql": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
    "predicted_sql": "SELECT \n    gsoffered\nFROM \n    schools\nWHERE \n    latitude = (SELECT MAX(longitude) FROM schools)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 83,
    "db_id": "california_schools",
    "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
    "evidence": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'",
    "gold_sql": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
    "predicted_sql": "SELECT \n  s.city, \n  COUNT(s.school) AS num_schools, \n  COUNT(DISTINCT s.cdscode) AS num_unique_schools\nFROM \n  schools s \n  JOIN frpm f ON s.cdscode = f.cdscode \n  JOIN satscores sc ON s.cdscode = sc.cdscode \nWHERE \n  s.virtual = 0 \n  AND s.magnet = 1 \n  AND f.low_grade = 'K' \n  AND f.high_grade = '8' \n  AND f.'NSLP Provision Status' = 'Multiple Provision Types' \nGROUP BY \n  s.city",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.low_grade",
    "difficulty": "challenging"
  },
  {
    "idx": 84,
    "db_id": "california_schools",
    "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
    "evidence": "",
    "gold_sql": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
    "predicted_sql": "SELECT \n    admfname1, \n    COUNT(*) as count, \n    district \nFROM \n    schools \nGROUP BY \n    admfname1, \n    district \nORDER BY \n    count DESC \nLIMIT 2",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 85,
    "db_id": "california_schools",
    "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
    "evidence": "Percent (%) Eligible Free (K-12) = `Free Meal Count (K-12)` / `Enrollment (K-12)` * 100%",
    "gold_sql": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
    "predicted_sql": "SELECT \n    frpm.percent_eligible_free_k12\nFROM \n    frpm\nJOIN \n    schools ON frpm.cdscode = schools.cdscode\nJOIN \n    satscores ON schools.cdscode = satscores.cds\nWHERE \n    schools.admfname1 = 'Alusine'\n    AND frpm.enrollment_k12 > 0",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: frpm.percent_eligible_free_k12",
    "difficulty": "moderate"
  },
  {
    "idx": 86,
    "db_id": "california_schools",
    "question": "What is the administrator's last name that oversees the school with Charter number 40? Indicate the district, the county where the school is situated, and the name of the school.",
    "evidence": "",
    "gold_sql": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'",
    "predicted_sql": "SELECT s.admlname1\nFROM schools s\nJOIN frpm f ON s.cdscode = f.cdscode\nWHERE f.charter_school = 'y' AND f.charter_school_number = 40",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: f.charter_school",
    "difficulty": "simple"
  },
  {
    "idx": 87,
    "db_id": "california_schools",
    "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
    "evidence": "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
    "gold_sql": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
    "predicted_sql": "SELECT \n    s.admemail1, s.admemail2, s.admemail3\nFROM \n    schools s\nWHERE \n    s.county = 'San Bernardino'\n    AND s.city = 'San Bernardino'\n    AND s.district = 'San Bernardino City Unified'\n    AND s.opendate BETWEEN '2009-01-01' AND '2010-12-31'\n    AND (s.statustype = 'Public Intermediate/Middle Schools' OR s.statustype = 'Unified Schools')\n    AND s.admemail1 IS NOT NULL\n    AND s.admemail2 IS NOT NULL\n    AND s.admemail3 IS NOT NULL",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 88,
    "db_id": "california_schools",
    "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
    "evidence": "",
    "gold_sql": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
    "predicted_sql": "SELECT \n  s.admemail1 AS admin_email,\n  s.sname AS school_name\nFROM \n  satscores s\n  JOIN schools s2 ON s.cds = s2.cdscode\nWHERE \n  s.numtsttakr = (SELECT MAX(numtsttakr) FROM satscores WHERE avgscrread >= 1500)\nORDER BY \n  s.numtsttakr DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: s.admemail1",
    "difficulty": "simple"
  },
  {
    "idx": 89,
    "db_id": "financial",
    "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
    "evidence": "A3 contains the data of region; 'POPLATEK PO OBRATU' represents for 'issuance after transaction'.",
    "gold_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
    "predicted_sql": "SELECT COUNT(*)\nFROM account\nJOIN client ON account.district_id = client.district_id\nJOIN disp ON account.account_id = disp.account_id\nJOIN card ON disp.disp_id = card.disp_id\nWHERE card.type = 'POPLATEK PO OBRATU'\nAND client.district_id IN (\n  SELECT district_id\n  FROM district\n  WHERE a3 LIKE '%V\u00fdchodn\u00ed \u010cechy%'\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 90,
    "db_id": "financial",
    "question": "How many accounts who have region in Prague are eligible for loans?",
    "evidence": "A3 contains the data of region",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
    "predicted_sql": "SELECT COUNT(DISTINCT a.account_id)\nFROM account a\nJOIN client c ON a.client_id = c.client_id\nJOIN district d ON c.district_id = d.district_id\nWHERE d.a3 LIKE '%Prague%'\nAND a.frequency ='monthly'\nAND a.date >= '2020-01-01'\nAND a.date <= '2020-12-31'\nAND NOT EXISTS (\n  SELECT 1\n  FROM loan l\n  WHERE l.account_id = a.account_id\n  AND l.status = 'default'\n)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.client_id",
    "difficulty": "simple"
  },
  {
    "idx": 91,
    "db_id": "financial",
    "question": "The average unemployment ratio of 1995 and 1996, which one has higher percentage?",
    "evidence": "A12 refers to unemploymant rate 1995; A13 refers to unemploymant rate 1996",
    "gold_sql": "SELECT DISTINCT IIF(AVG(A13) > AVG(A12), '1996', '1995') FROM district",
    "predicted_sql": "SELECT \n    AVG(CASE WHEN A12 > 0 THEN A12 ELSE 0 END) AS '95_unemp_rate,\n    AVG(CASE WHEN A13 > 0 THEN A13 ELSE 0 END) AS '96_unemp_rate,\n    CASE \n        WHEN AVG(CASE WHEN A12 > 0 THEN A12 ELSE 0 END) > AVG(CASE WHEN A13 > 0 THEN A13 ELSE 0 END) \n        THEN '1995'\n        ELSE '1996'\n    END AS 'higher_unemp_rate'\nFROM \n    district\nWHERE \n    A12 > 0 OR A13 > 0",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: unrecognized token: \"96_unemp_rate\"",
    "difficulty": "simple"
  },
  {
    "idx": 92,
    "db_id": "financial",
    "question": "List out the no. of districts that have female average salary is more than 6000 but less than 10000?",
    "evidence": "A11 refers to average salary; Female mapps to gender = 'F'",
    "gold_sql": "SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000",
    "predicted_sql": "SELECT COUNT(DISTINCT district.district_id)\nFROM financial.district\nJOIN financial.client ON district.district_id = client.district_id\nJOIN financial.disp ON client.client_id = disp.client_id\nJOIN financial.account ON disp.account_id = account.account_id\nWHERE client.gender = 'F' AND A11 > 6000 AND A11 < 10000",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: financial.district",
    "difficulty": "simple"
  },
  {
    "idx": 93,
    "db_id": "financial",
    "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
    "evidence": "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary.",
    "gold_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
    "predicted_sql": "SELECT \n    COUNT(*)\nFROM \n    client c\nJOIN \n    district d ON c.district_id = d.district_id\nJOIN \n    disp dp ON c.client_id = dp.client_id\nJOIN \n    account a ON dp.account_id = a.account_id\nWHERE \n    c.gender = 'M' \n    AND d.a3 = 'North Bohemia' \n    AND a11 > 8000",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 94,
    "db_id": "financial",
    "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
    "evidence": "Female means gender = 'F'; A11 refers to average salary; Gap = highest average salary - lowest average salary; If the person A's birthdate > B's birthdate, it means that person B is order than person A.",
    "gold_sql": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
    "predicted_sql": "SELECT \n  a.account_id, \n  c.gender, \n  d.a11 AS average_salary, \n  (SELECT MAX(d.a11) - MIN(d.a11) FROM district d) AS gap\nFROM \n  account a \n  JOIN client c ON a.district_id = c.district_id \n  JOIN district d ON c.district_id = d.district_id \nWHERE \n  c.gender = 'F' \nORDER BY \n  c.birth_date DESC, \n  d.a11 ASC \nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 95,
    "db_id": "financial",
    "question": "List out the account numbers of clients who are youngest and have highest average salary?",
    "evidence": "If the person A's birthdate < B's birthdate, it means that person B is younger than person A; A11 refers to average salary",
    "gold_sql": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
    "predicted_sql": "SELECT a.account_id\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nJOIN account a ON c.client_id = a.client_id\nWHERE c.birth_date = (SELECT MIN(birth_date) FROM client)\nAND d.a11 = (SELECT MAX(a11) FROM district)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.client_id",
    "difficulty": "moderate"
  },
  {
    "idx": 96,
    "db_id": "financial",
    "question": "How many customers who choose statement of weekly issuance are Owner?",
    "evidence": "'POPLATEK TYDNE' stands for weekly issuance",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
    "predicted_sql": "SELECT COUNT(DISTINCT c.client_id) \nFROM client c, disp d \nWHERE c.client_id = d.client_id AND d.type = 'Owner' AND d.disp_id IN \n  (SELECT d2.disp_id \n   FROM disp d2, account a2 \n   WHERE d2.client_id = a2.account_id AND a2.frequency = 'POPLATEK TYDNE')",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 97,
    "db_id": "financial",
    "question": "List out the id number of client who choose statement of issuance after transaction are Disponent?",
    "evidence": "'POPLATEK PO OBRATU' stands for issuance after transaction",
    "gold_sql": "SELECT T2.client_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.type = 'DISPONENT'",
    "predicted_sql": "SELECT c.client_id \nFROM client c \nJOIN disp d ON c.client_id = d.client_id \nJOIN card ca ON d.disp_id = ca.disp_id \nWHERE ca.type = 'Disponent' \nAND EXISTS (\n  SELECT 1 \n  FROM trans t \n  WHERE t.account_id = d.account_id \n  AND t.type = 'POPLATEK PO OBRATU'\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 98,
    "db_id": "financial",
    "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
    "evidence": "'POPLATEK TYDNE' stands for weekly issuance",
    "gold_sql": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
    "predicted_sql": "SELECT *\nFROM account\nWHERE loan_id IN (\n  SELECT loan_id\n  FROM loan\n  WHERE date >= '1997-01-01' AND date <= '1997-12-31'\n  AND status = 'approved'\n)\nAND frequency = 'POPLATEK TYDNE'\nORDER BY approved_amount\nLIMIT 10",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: loan_id",
    "difficulty": "moderate"
  },
  {
    "idx": 99,
    "db_id": "financial",
    "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
    "evidence": "Loan validity more than 12 months refers to duration > 12",
    "gold_sql": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
    "predicted_sql": "SELECT \n  a.account_id, \n  a.frequency, \n  a.date, \n  l.amount AS approved_amount\nFROM \n  account a\n  JOIN loan l ON a.account_id = l.account_id\nWHERE \n  l.duration > 12\n  AND a.date LIKE '1993%'\nORDER BY \n  l.amount DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 100,
    "db_id": "financial",
    "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
    "evidence": "Customers refer to clients; Female refers to gender = 'F'; Names of districts appear in column A2",
    "gold_sql": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND STRFTIME('%Y', T2.birth_date) < '1950' AND T1.A2 = 'Sokolov'",
    "predicted_sql": "SELECT COUNT(*)\nFROM client\nWHERE gender = 'F'\nAND birth_date < '1950-01-01'\nAND district_id IN (\n  SELECT district_id\n  FROM district\n  WHERE a2 = 'Sokolov'\n)",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 101,
    "db_id": "financial",
    "question": "List out the accounts who have the earliest trading date in 1995 ?",
    "evidence": "",
    "gold_sql": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
    "predicted_sql": "SELECT \n    a.account_id,\n    a.date\nFROM \n    account a\nWHERE \n    a.date >= '1995-01-01' AND a.date <= '1995-12-31'\nORDER BY \n    a.date\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 102,
    "db_id": "financial",
    "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
    "evidence": "",
    "gold_sql": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
    "predicted_sql": "SELECT a.account_id, a.frequency, a.date, c.client_id, c.gender, c.birth_date, c.district_id\nFROM account a\nJOIN client c ON a.account_id = c.district_id\nWHERE a.date < '1997-01-01' AND a.amount > 3000",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.amount",
    "difficulty": "simple"
  },
  {
    "idx": 103,
    "db_id": "financial",
    "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
    "evidence": "",
    "gold_sql": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
    "predicted_sql": "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.issued = '1994-03-03'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 104,
    "db_id": "financial",
    "question": "The transaction of 840 USD happened in 1998/10/14, when was this account opened?",
    "evidence": "",
    "gold_sql": "SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'",
    "predicted_sql": "SELECT a.date\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE t.amount = 840 AND t.date = '1998-10-14'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 105,
    "db_id": "financial",
    "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
    "evidence": "",
    "gold_sql": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
    "predicted_sql": "SELECT \n  a.district_id\nFROM \n  account a\n  JOIN \n    disp d ON a.account_id = d.account_id\n  JOIN \n    client c ON d.client_id = c.client_id\nWHERE \n  a.date = '1994-08-25' \n  AND a.frequency = 'LOAN'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 106,
    "db_id": "financial",
    "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
    "evidence": "",
    "gold_sql": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
    "predicted_sql": "SELECT MAX(t.amount) AS max_amount\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN client c ON a.district_id = c.district_id\nJOIN disp d ON c.client_id = d.client_id AND a.account_id = d.account_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.issued = '1996-10-21'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 107,
    "db_id": "financial",
    "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
    "evidence": "Earlier birthdate refers to older age; A11 refers to average salary",
    "gold_sql": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.A11 DESC, T2.birth_date ASC LIMIT 1",
    "predicted_sql": "SELECT c.gender\nFROM client c\nJOIN account a ON c.client_id = a.account_id\nJOIN district d ON c.district_id = d.district_id\nWHERE a.date = (SELECT MIN(a2) FROM district d2 WHERE d2.a11 = (SELECT MAX(a11) FROM district))\nORDER BY c.birth_date ASC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 108,
    "db_id": "financial",
    "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
    "evidence": "",
    "gold_sql": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
    "predicted_sql": "SELECT \n    c.client_id, \n    c.gender, \n    c.birth_date, \n    d.a2 AS district, \n    l.amount AS loan_amount, \n    t.amount AS first_transaction_amount\nFROM \n    client c\nJOIN \n    disp d ON c.client_id = d.client_id\nJOIN \n    account a ON d.account_id = a.account_id\nJOIN \n    loan l ON a.account_id = l.account_id\nJOIN \n    trans t ON a.account_id = t.account_id\nWHERE \n    l.amount = (SELECT MAX(l2.amount) FROM loan l2)\nORDER BY \n    t.date\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: d.a2",
    "difficulty": "simple"
  },
  {
    "idx": 109,
    "db_id": "financial",
    "question": "How many clients opened their accounts in Jesenik branch were women?",
    "evidence": "A2 has region names; Woman and female share the same meaning; female refers to gender = 'F'",
    "gold_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'",
    "predicted_sql": "SELECT COUNT(*)\nFROM client c\nJOIN account a ON c.client_id = a.account_id\nJOIN district d ON c.district_id = d.district_id\nWHERE d.a2 = 'Jesenik' AND c.gender = 'F'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 110,
    "db_id": "financial",
    "question": "What is the disposition id of the client who made 5100 USD transaction in 1998/9/2?",
    "evidence": "",
    "gold_sql": "SELECT T1.disp_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.date='1997-08-20' AND T3.amount = 5100",
    "predicted_sql": "SELECT d.disp_id \nFROM client c \nJOIN disp d ON c.client_id = d.client_id \nJOIN account a ON d.account_id = a.account_id \nJOIN trans t ON a.account_id = t.account_id \nWHERE t.date = '1998-09-02' AND t.amount = 5100",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 111,
    "db_id": "financial",
    "question": "How many accounts were opened in Litomerice in 1996?",
    "evidence": "A2 refers to district name; Litomerice is one of district names.",
    "gold_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1996' AND T1.A2 = 'Litomerice'",
    "predicted_sql": "SELECT COUNT(*) \nFROM account \nWHERE district_id IN (SELECT district_id FROM district WHERE a2 = 'Litomerice') \nAND date BETWEEN '1996-01-01' AND '1996-12-31'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 112,
    "db_id": "financial",
    "question": "For the female client who was born in 1976/1/29, which district did she opened her account?",
    "evidence": "Female refers to gender = 'F'; A2 refers to district names",
    "gold_sql": "SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'",
    "predicted_sql": "SELECT d.a2\nFROM client c\nJOIN account a ON c.client_id = a.account_id\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'F' AND c.birth_date = '1976-01-29'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 113,
    "db_id": "financial",
    "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
    "evidence": "",
    "gold_sql": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
    "predicted_sql": "SELECT c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.amount = 98832 AND l.date = '1996-01-03'\nAND c.client_id IN (\n  SELECT d.client_id\n  FROM disp d\n  JOIN account a ON d.account_id = a.account_id\n  WHERE a.frequency = 'Loan'\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 114,
    "db_id": "financial",
    "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
    "evidence": "A3 stands for region names",
    "gold_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' ORDER BY T1.date ASC LIMIT 1",
    "predicted_sql": "SELECT \n    a.account_id\nFROM \n    account a \nJOIN \n    client c ON a.client_id = c.client_id \nJOIN \n    district d ON c.district_id = d.district_id \nWHERE \n    c.client_id = (SELECT client_id FROM client ORDER BY account_id LIMIT 1)\n    AND d.a2 = 'Prague'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: account_id",
    "difficulty": "simple"
  },
  {
    "idx": 115,
    "db_id": "financial",
    "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
    "evidence": "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants.",
    "gold_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
    "predicted_sql": "SELECT \n    A4 AS 'Region', \n    COUNT(CASE WHEN gender = 'M' THEN 1 ELSE NULL END) AS 'Male Clients', \n    COUNT(CASE WHEN gender = 'F' THEN 1 ELSE NULL END) AS 'Female Clients', \n    (COUNT(CASE WHEN gender = 'M' THEN 1 ELSE NULL END) * 100.0 / \n     COUNT(CASE WHEN gender IS NOT NULL THEN 1 ELSE NULL END)) AS 'Percentage of Male Clients'\nFROM \n    client\nJOIN \n    district ON client.district_id = district.district_id\nWHERE \n    district.a4 = (SELECT MAX(a4) FROM district WHERE a2 = 'South Bohemia')\nGROUP BY \n    A4\nORDER BY \n    'Percentage of Male Clients' DESC",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 116,
    "db_id": "financial",
    "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
    "evidence": "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%",
    "gold_sql": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
    "predicted_sql": "SELECT \n    (t2.balance - t1.balance) / t1.balance * 100 AS increase_rate\nFROM \n    (SELECT \n         account_id, \n         balance, \n         DATE_FORMAT(date, '%Y/%m/%d') AS date\n     FROM \n         trans\n     WHERE \n         account_id IN (SELECT \n                          account_id \n                         FROM \n                          loan \n                         WHERE \n                          DATE(date) = '1993-07-05' \n                         AND status = 'APPROVED' \n                         ORDER BY \n                          date LIMIT 1) \n     AND DATE(date) BETWEEN '1993-03-22' AND '1998-12-27') AS t1\nJOIN \n    (SELECT \n         account_id, \n         balance, \n         DATE_FORMAT(date, '%Y/%m/%d') AS date\n     FROM \n         trans\n     WHERE \n         account_id IN (SELECT \n                          account_id \n                         FROM \n                          loan \n                         WHERE \n                          DATE(date) = '1993-07-05' \n                         AND status = 'APPROVED' \n                         ORDER BY \n                          date LIMIT 1) \n     AND DATE(date) BETWEEN '1993-03-22'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: incomplete input",
    "difficulty": "challenging"
  },
  {
    "idx": 117,
    "db_id": "financial",
    "question": "What is the percentage of loan amount that has been fully paid with no issue.",
    "evidence": "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%",
    "gold_sql": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
    "predicted_sql": "SELECT \n  (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) / \n   (SELECT SUM(amount) FROM loan)) * 100 AS percentage\nFROM \n  loan\nWHERE \n  status = 'A'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 118,
    "db_id": "financial",
    "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
    "evidence": "Status = 'C' stands for running contract, ok so far; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100.",
    "gold_sql": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
    "predicted_sql": "SELECT \n    ROUND(((SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) * 100) / (SELECT COUNT(*) FROM loan WHERE amount < 100000)), 2) AS percentage\nFROM \n    loan\nWHERE \n    amount < 100000",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 119,
    "db_id": "financial",
    "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
    "evidence": "Records about district names could be found in A2; A3 contains the information about regions. 'POPLATEK PO OBRATU' stands for issuance after transaction",
    "gold_sql": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
    "predicted_sql": "SELECT \n  a.account_id, \n  d.a2 AS district_name, \n  d.a3 AS district_region\nFROM \n  account a \n  JOIN district d ON a.district_id = d.district_id\nWHERE \n  a.date LIKE '1993%' AND \n  EXISTS (\n    SELECT 1 \n    FROM trans t \n    WHERE t.account_id = a.account_id \n    AND t.date > t.operation \n  )\nORDER BY \n  a.account_id",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 120,
    "db_id": "financial",
    "question": "From Year 1995 to 2000, who are the accounts holders from 'east Bohemia'. State the account ID the frequency of statement issuance.",
    "evidence": "Accounts holder refers to the person who own this account.",
    "gold_sql": "SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'",
    "predicted_sql": "SELECT \n  a.account_id, \n  c.client_id, \n  c.gender, \n  c.birth_date, \n  a.frequency\nFROM \n  account a \n  JOIN client c ON a.account_id = c.client_id \n  JOIN district d ON c.district_id = d.district_id \nWHERE \n  a.date BETWEEN '1995-01-01' AND '2000-12-31' \n  AND d.a2 LIKE '%East Bohemia%'\nORDER BY \n  a.account_id",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 121,
    "db_id": "financial",
    "question": "List account ID and account opening date for accounts from 'Prachatice'.",
    "evidence": "A2 refers to the names of districts.",
    "gold_sql": "SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Prachatice'",
    "predicted_sql": "SELECT \n  a.account_id,\n  a.date\nFROM \n  account a\nJOIN \n  client c ON a.district_id = c.district_id\nJOIN \n  district d ON c.district_id = d.district_id\nWHERE \n  d.a2 = 'Prachatice'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 122,
    "db_id": "financial",
    "question": "State the district and region for loan ID '4990'.",
    "evidence": "A2, A3 contains the information about district and region respectively.",
    "gold_sql": "SELECT T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
    "predicted_sql": "SELECT \n  d.a2, d.a3\nFROM \n  loan l\n  JOIN account a ON l.account_id = a.account_id\n  JOIN client c ON a.client_id = c.client_id\n  JOIN district d ON c.district_id = d.district_id\nWHERE \n  l.loan_id = '4990'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.client_id",
    "difficulty": "simple"
  },
  {
    "idx": 123,
    "db_id": "financial",
    "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
    "evidence": "A2 contains district names and A3 contains region names.",
    "gold_sql": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
    "predicted_sql": "SELECT \n    a.account_id, \n    d.a2 AS district, \n    d.a3 AS region\nFROM \n    loan l\nJOIN \n    account a ON l.account_id = a.account_id\nJOIN \n    district d ON a.district_id = d.district_id\nWHERE \n    l.amount > 300000",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 124,
    "db_id": "financial",
    "question": "List the loan ID, district and average salary for loan with duration of 60 months.",
    "evidence": "A3 refers to regions; A11 refers to average salary",
    "gold_sql": "SELECT T3.loan_id, T2.A2, T2.A11 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.duration = 60",
    "predicted_sql": "SELECT \n  l.loan_id, \n  d.a3 AS region, \n  c.a11 AS average_salary\nFROM \n  loan l \n  INNER JOIN account a ON l.account_id = a.account_id \n  INNER JOIN client c ON a.client_id = c.client_id \n  INNER JOIN district d ON c.district_id = d.district_id \nWHERE \n  l.duration = 60",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: c.a11",
    "difficulty": "simple"
  },
  {
    "idx": 125,
    "db_id": "financial",
    "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
    "evidence": "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'",
    "gold_sql": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
    "predicted_sql": "SELECT \n  d.a2 AS district, \n  ((d.a13 - d.a12) / d.a12) * 100 AS unemployment_increment_rate\nFROM \n  financial.district d\nWHERE \n  d.a12 > 0 AND d.a13 > 0\nORDER BY \n  unemployment_increment_rate DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: financial.district",
    "difficulty": "challenging"
  },
  {
    "idx": 126,
    "db_id": "financial",
    "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
    "evidence": "A2 contains the information about district.",
    "gold_sql": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
    "predicted_sql": "SELECT \n    (SELECT COUNT(*) \n     FROM account \n     WHERE district_id = (SELECT district_id \n                           FROM district \n                           WHERE a2 = 'Decin')) / \n    (SELECT COUNT(*) \n     FROM account) * 100 AS percentage",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 127,
    "db_id": "financial",
    "question": "List the account IDs with monthly issuance of statements.",
    "evidence": "'POPLATEK MESICNE' stands for monthly issuance",
    "gold_sql": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
    "predicted_sql": "SELECT \n    a.account_id\nFROM \n    account a\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nJOIN \n    district district ON c.district_id = district.district_id\nWHERE \n    a.frequency = 'POPLATEK MESICNE'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 128,
    "db_id": "financial",
    "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
    "evidence": "A2 refers to districts; Female refers to gender = 'F'",
    "gold_sql": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
    "predicted_sql": "SELECT \n  a2 AS district, \n  COUNT(CASE WHEN gender = 'F' THEN 1 ELSE NULL END) AS female_count\nFROM \n  client \nWHERE \n  gender = 'F'\nGROUP BY \n  a2\nORDER BY \n  female_count DESC\nLIMIT 9",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a2",
    "difficulty": "moderate"
  },
  {
    "idx": 129,
    "db_id": "financial",
    "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
    "evidence": "Non-credit card withdraws refers to type = 'VYDAJ'; January 1996 can be found by date LIKE '1996-01%' in the database; A2 means district names",
    "gold_sql": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
    "predicted_sql": "SELECT \n    a2 AS district_name,\n    SUM(amount) AS total_withdrawal\nFROM \n    trans \nWHERE \n    type = 'VYDAJ' \n    AND date LIKE '1996-01%'\nGROUP BY \n    a2\nORDER BY \n    total_withdrawal DESC\nLIMIT 10",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a2",
    "difficulty": "moderate"
  },
  {
    "idx": 130,
    "db_id": "financial",
    "question": "How many of the account holders in South Bohemia still do not own credit cards?",
    "evidence": "A3 contains the region names; South Bohemia is one of region names.",
    "gold_sql": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'",
    "predicted_sql": "SELECT COUNT(DISTINCT a.client_id) \nFROM account a \nJOIN client c ON a.client_id = c.client_id \nJOIN district d ON c.district_id = d.district_id \nWHERE d.a3 = 'South Bohemia' \nAND NOT EXISTS (\n  SELECT 1 \n  FROM card \n  WHERE card.disp_id = a.disp_id\n)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.client_id",
    "difficulty": "moderate"
  },
  {
    "idx": 131,
    "db_id": "financial",
    "question": "Which district has highest active loan?",
    "evidence": "A3 refers to district names; Active loan refers to running contracts; Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
    "gold_sql": "SELECT T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.A3 ORDER BY SUM(T3.amount) DESC LIMIT 1",
    "predicted_sql": "SELECT \n    d.A3 AS District,\n    SUM(l.amount) AS Active_Loan\nFROM \n    loan l\n    JOIN account a ON l.account_id = a.account_id\n    JOIN district d ON a.district_id = d.district_id\nWHERE \n    l.status = 'C'\nGROUP BY \n    d.A3\nORDER BY \n    Active_Loan DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 132,
    "db_id": "financial",
    "question": "What is the average loan amount by male borrowers?",
    "evidence": "Male refers to gender = 'M'",
    "gold_sql": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
    "predicted_sql": "SELECT AVG(loan.amount) AS average_loan_amount\nFROM loan\nJOIN account ON loan.account_id = account.account_id\nJOIN client ON account.client_id = client.client_id\nWHERE client.gender = 'M'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: account.client_id",
    "difficulty": "simple"
  },
  {
    "idx": 133,
    "db_id": "financial",
    "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
    "evidence": "A2 refers to district names; A13 refers to unemploymant rate in 1996",
    "gold_sql": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1",
    "predicted_sql": "SELECT \n  d.a2 AS district_name, \n  d.a3 AS branch_location, \n  d.a13 AS unemployment_rate\nFROM \n  district d\nWHERE \n  d.a13 = (SELECT MAX(a13) FROM district)\nORDER BY \n  d.a13 DESC",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 134,
    "db_id": "financial",
    "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
    "evidence": "A16 stands for no. of committed crimes 1996",
    "gold_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
    "predicted_sql": "SELECT COUNT(DISTINCT a.account_id)\nFROM account a\nJOIN client c ON a.district_id = c.district_id\nJOIN disp d ON c.client_id = d.client_id AND a.account_id = d.account_id\nJOIN district D ON a.district_id = D.district_id\nWHERE D.a16 = (SELECT MAX(D.a16) FROM district D)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 135,
    "db_id": "financial",
    "question": "After making a credit card withdrawal, how many account/s with monthly issuance has a negative balance?",
    "evidence": "Negative balance means balance < 0; Operation = 'VYBER KARTOU' stands for credit card withdraw. Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.balance < 0 AND T1.operation = 'VYBER KARTOU' AND T2.frequency = 'POPLATEK MESICNE'",
    "predicted_sql": "SELECT COUNT(DISTINCT a.account_id)\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE t.type = 'VYBER KARTOU' \nAND a.frequency = 'POPLATEK MESICNE' \nAND t.balance < 0",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 136,
    "db_id": "financial",
    "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
    "evidence": "Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
    "predicted_sql": "SELECT \n  COUNT(DISTINCT a.account_id) \nFROM \n  account a \n  JOIN disp d ON a.account_id = d.account_id \n  JOIN client c ON d.client_id = c.client_id \n  JOIN loan l ON a.account_id = l.account_id \nWHERE \n  a.frequency = 'POPLATEK MESICNE' \n  AND l.date BETWEEN '1995-01-01' AND '1997-12-31' \n  AND l.amount >= 250000 \n  AND l.status = 'APPROVED'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 137,
    "db_id": "financial",
    "question": "How many accounts have running contracts in Branch location 1?",
    "evidence": "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
    "predicted_sql": "SELECT COUNT(*)\nFROM account\nJOIN loan ON account.account_id = loan.account_id\nJOIN district ON account.district_id = district.district_id\nWHERE district.a2 = 1 AND loan.status IN ('C', 'D')",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 138,
    "db_id": "financial",
    "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
    "evidence": "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995",
    "gold_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
    "predicted_sql": "SELECT COUNT(*)\nFROM client\nWHERE client.district_id = \n  (SELECT district_id\n   FROM district\n   WHERE a15 = \n     (SELECT MAX(a15)\n      FROM district\n      WHERE a15 < \n        (SELECT MAX(a15)\n         FROM district)))",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 139,
    "db_id": "financial",
    "question": "How many high-level credit cards have \"OWNER\" type of disposition?",
    "evidence": "High-level credit cards refers to the cards with the gold type.",
    "gold_sql": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'",
    "predicted_sql": "SELECT COUNT(*)\nFROM card\nWHERE type = 'GOLD' AND disp_id IN (\n    SELECT disp_id\n    FROM disp\n    WHERE type = 'OWNER'\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 140,
    "db_id": "financial",
    "question": "How many accounts are there in the district of \"Pisek\"?",
    "evidence": "A2 refers to district name",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Pisek'",
    "predicted_sql": "SELECT \n    COUNT(DISTINCT a.account_id)\nFROM \n    account a\n    JOIN district d ON a.district_id = d.district_id\nWHERE \n    d.a2 = 'Pisek'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 141,
    "db_id": "financial",
    "question": "Which districts have transactions greater than USS$10,000 in 1997?",
    "evidence": "",
    "gold_sql": "SELECT T1.district_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date) = '1997' GROUP BY T1.district_id HAVING SUM(T3.amount) > 10000",
    "predicted_sql": "SELECT \n  d.a2 AS district_name\nFROM \n  financial.trans t\n  JOIN financial.account a ON t.account_id = a.account_id\n  JOIN financial.client c ON a.client_id = c.client_id\n  JOIN financial.district d ON c.district_id = d.district_id\nWHERE \n  t.date >= '1997-01-01' AND t.date < '1998-01-01'\n  AND t.amount > 10000\nGROUP BY \n  d.a2",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: financial.trans",
    "difficulty": "simple"
  },
  {
    "idx": 142,
    "db_id": "financial",
    "question": "Which accounts placed orders for household payment in Pisek?",
    "evidence": "k_symbol = 'SIPO' refers to household payment",
    "gold_sql": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.k_symbol = 'SIPO' AND T3.A2 = 'Pisek'",
    "predicted_sql": "SELECT \n  a.account_id, \n  a.district_id, \n  c.client_id, \n  c.gender, \n  c.birth_date, \n  o.order_id, \n  o.amount, \n  o.bank_to, \n  o.account_to, \n  o.k_symbol\nFROM \n  account a \n  JOIN client c ON a.client_id = c.client_id \n  JOIN disp d ON a.account_id = d.account_id \n  JOIN district district ON a.district_id = district.district_id \n  JOIN order o ON a.account_id = o.account_id \nWHERE \n  o.k_symbol = 'SIPO' \n  AND a.district_id = (SELECT district_id FROM district WHERE a2 = 'Pisek')",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"order\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 143,
    "db_id": "financial",
    "question": "What are the accounts that have gold credit cards?",
    "evidence": "",
    "gold_sql": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
    "predicted_sql": "SELECT \n  a.account_id, \n  c.client_id, \n  c.gender, \n  c.birth_date, \n  d.district_id, \n  d.a2, \n  d.a3, \n  d.a4, \n  d.a5, \n  d.a6, \n  d.a7, \n  d.a8, \n  d.a9, \n  d.a10, \n  d.a11, \n  d.a12, \n  d.a13, \n  d.a14, \n  d.a15, \n  d.a16\nFROM \n  account a \n  INNER JOIN client c ON a.district_id = c.district_id \n  INNER JOIN disp d ON a.account_id = d.account_id \n  INNER JOIN card cd ON d.disp_id = cd.disp_id \nWHERE \n  cd.type = 'Gold'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: d.district_id",
    "difficulty": "simple"
  },
  {
    "idx": 144,
    "db_id": "financial",
    "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
    "evidence": "Operation = 'VYBER KARTOU' refers to credit card withdrawn",
    "gold_sql": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
    "predicted_sql": "SELECT \n  AVG(amount) \nFROM \n  trans \nWHERE \n  year(date) = 2021 \n  AND type = 'KARTOU' \n  AND operation = 'VYBER KARTOU'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: year",
    "difficulty": "moderate"
  },
  {
    "idx": 145,
    "db_id": "financial",
    "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
    "evidence": "Operation = 'VYBER KARTOU' refers to credit card withdrawal",
    "gold_sql": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
    "predicted_sql": "SELECT \n    a.account_id\nFROM \n    account a \nJOIN \n    trans t ON a.account_id = t.account_id \nJOIN \n    disp d ON a.account_id = d.account_id \nJOIN \n    client c ON d.client_id = c.client_id \nWHERE \n    t.date BETWEEN '1998-01-01' AND '1998-12-31' \n    AND t.type = 'VYBER KARTOU' \n    AND t.amount < (SELECT AVG(t2.amount) FROM trans t2 WHERE t2.date BETWEEN '1998-01-01' AND '1998-12-31' AND t2.type = 'VYBER KARTOU')",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 146,
    "db_id": "financial",
    "question": "Who are the female account holders who own credit cards and also have loans?",
    "evidence": "Female refers to gender = 'F'",
    "gold_sql": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
    "predicted_sql": "SELECT c.client_id, c.gender, c.birth_date, c.district_id, a.account_id, c.card_id, l.loan_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN card ca ON d.disp_id = ca.disp_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'F'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: c.card_id",
    "difficulty": "simple"
  },
  {
    "idx": 147,
    "db_id": "financial",
    "question": "How many female clients' accounts are in the region of South Bohemia?",
    "evidence": "Female refers to gender = 'F'; A3 contains the region 'south Bohemia'",
    "gold_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A3 = 'south Bohemia'",
    "predicted_sql": "SELECT COUNT(DISTINCT c.client_id) \nFROM client c \nJOIN district d ON c.district_id = d.district_id \nWHERE d.a3 LIKE '%south Bohemia%' AND c.gender = 'F'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 148,
    "db_id": "financial",
    "question": "Please list the accounts whose district is Tabor that are eligible for loans.",
    "evidence": "District refers to column A2; when the account type = 'OWNER', it's eligible for loans",
    "gold_sql": "SELECT T2.account_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'OWNER' AND T1.A2 = 'Tabor'",
    "predicted_sql": "SELECT *\nFROM account\nWHERE district_id IN (\n  SELECT district_id\n  FROM district\n  WHERE a2 = 'Tabor'\n) AND account_type = 'OWNER'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: account_type",
    "difficulty": "moderate"
  },
  {
    "idx": 149,
    "db_id": "financial",
    "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
    "evidence": "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans",
    "gold_sql": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
    "predicted_sql": "SELECT \n  a.type AS account_type\nFROM \n  account a\n  JOIN client c ON a.district_id = c.district_id\n  JOIN district d ON c.district_id = d.district_id\nWHERE \n  a.type!= 'OWNER'\n  AND d.a11 > 8000\n  AND d.a11 <= 9000",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.type",
    "difficulty": "challenging"
  },
  {
    "idx": 150,
    "db_id": "financial",
    "question": "How many accounts in North Bohemia has made a transaction with the partner's bank being AB?",
    "evidence": "A3 contains the region names; North Bohemia is a region.",
    "gold_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.bank = 'AB' AND T1.A3 = 'north Bohemia'",
    "predicted_sql": "SELECT COUNT(*)\nFROM trans\nWHERE account_id IN (\n  SELECT account_id\n  FROM account\n  WHERE district_id IN (\n    SELECT district_id\n    FROM district\n    WHERE a3 LIKE '%North Bohemia%'\n  )\n) AND bank LIKE '%AB%'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 151,
    "db_id": "financial",
    "question": "Please list the name of the districts with accounts that made withdrawal transactions.",
    "evidence": "A2 refers to district name; type = 'VYDAJ' stands for withdrawal transactions",
    "gold_sql": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ'",
    "predicted_sql": "SELECT \n  d.a2 AS district_name,\n  COUNT(t.trans_id) AS num_withdrawals\nFROM \n  account a\n  JOIN district d ON a.district_id = d.district_id\n  JOIN trans t ON a.account_id = t.account_id\nWHERE \n  t.type = 'VYDAJ'\nGROUP BY \n  d.a2\nORDER BY \n  num_withdrawals DESC",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 152,
    "db_id": "financial",
    "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
    "evidence": "A3 refers to region names; A15 stands for the average number of crimes commited in 1995.",
    "gold_sql": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
    "predicted_sql": "SELECT AVG(a15) AS average_crimes\nFROM district\nWHERE a3 IN (\n  SELECT district.a3\n  FROM district\n  JOIN account ON district.district_id = account.district_id\n  WHERE date >= '1997-01-01'\n  GROUP BY district.a3\n  HAVING COUNT(account.account_id) > 0 AND a15 > 4000\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 153,
    "db_id": "financial",
    "question": "How many 'classic' cards are eligible for loan?",
    "evidence": "when the account type = 'OWNER', it's eligible for loan",
    "gold_sql": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'classic' AND T2.type = 'OWNER'",
    "predicted_sql": "SELECT COUNT(*)\nFROM card c\nJOIN disp d ON c.disp_id = d.disp_id\nJOIN client cl ON d.client_id = cl.client_id\nJOIN account a ON d.account_id = a.account_id\nWHERE c.type = 'CLASSIC' AND a.frequency = 'OWNER'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 154,
    "db_id": "financial",
    "question": "How many male clients in 'Hl.m. Praha' district?",
    "evidence": "District data appears in the A2; Male means that gender = 'M'",
    "gold_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'",
    "predicted_sql": "SELECT COUNT(*)\nFROM client\nWHERE gender = 'M'\nAND district_id = (\n  SELECT district_id\n  FROM district\n  WHERE a2 = 'Hl.m. Praha'\n)",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 155,
    "db_id": "financial",
    "question": "How many percent of 'Gold' cards were issued prior to 1998?",
    "evidence": "Percent of Gold = [ count(type = 'gold' and issued date < 1998) / count(all cards)] * 100%",
    "gold_sql": "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) FROM card",
    "predicted_sql": "SELECT \n  (COUNT(CASE WHEN type = 'gold' AND issued < '1998-01-01' THEN 1 END) / \n   COUNT(*)) * 100 \nFROM \n  card",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 156,
    "db_id": "financial",
    "question": "Who is the owner of the account with the largest loan amount?",
    "evidence": "",
    "gold_sql": "SELECT T1.client_id FROM disp AS T1 INNER JOIN account AS T3 ON T1.account_id = T3.account_id INNER JOIN loan AS T2 ON T3.account_id = T2.account_id WHERE T1.type = 'OWNER' ORDER BY T2.amount DESC LIMIT 1",
    "predicted_sql": "SELECT c.client_id, c.gender, c.birth_date, c.district_id, \n       SUM(l.amount) AS total_loan\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nGROUP BY c.client_id, c.gender, c.birth_date, c.district_id\nORDER BY total_loan DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 157,
    "db_id": "financial",
    "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
    "evidence": "A15 contains information about number of committed crimes in 1995",
    "gold_sql": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
    "predicted_sql": "SELECT a15.a15 AS crimes\nFROM district AS a15\nJOIN account AS a ON a15.a15 = a.district_id\nWHERE a.account_id = 532",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 158,
    "db_id": "financial",
    "question": "What is the district Id of the account that placed the order with the id 33333?",
    "evidence": "",
    "gold_sql": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
    "predicted_sql": "SELECT d.district_id\nFROM order o\nJOIN account a ON o.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE o.order_id = 33333",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"order\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 159,
    "db_id": "financial",
    "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
    "evidence": "operation = 'VYBER' refers to withdrawal in cash",
    "gold_sql": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
    "predicted_sql": "SELECT t.date, t.amount, t.balance, t.k_symbol, t.bank, t.account\nFROM trans t\nJOIN client c ON t.account = c.client_id\nWHERE c.client_id = 3356 AND t.operation = 'VYBER'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 160,
    "db_id": "financial",
    "question": "Among the weekly issuance accounts, how many have a loan of under 200000?",
    "evidence": "frequency = 'POPLATEK TYDNE' stands for weekly issuance",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000",
    "predicted_sql": "SELECT \n    COUNT(DISTINCT a.account_id)\nFROM \n    account a \n    JOIN disp d ON a.account_id = d.account_id \n    JOIN client c ON d.client_id = c.client_id \n    JOIN district district ON c.district_id = district.district_id \nWHERE \n    a.frequency = 'POPLATEK TYDNE' \n    AND a.loan_id IN (SELECT loan_id FROM loan WHERE amount < 200000)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.loan_id",
    "difficulty": "simple"
  },
  {
    "idx": 161,
    "db_id": "financial",
    "question": "What type of credit card does the client with the id 13539 own?",
    "evidence": "",
    "gold_sql": "SELECT T3.type FROM disp AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T1.disp_id = T3.disp_id WHERE T2.client_id = 13539",
    "predicted_sql": "SELECT \n  c.type \nFROM \n  client c \n  JOIN disp d ON c.client_id = d.client_id \n  JOIN card ca ON d.disp_id = ca.disp_id \nWHERE \n  c.client_id = 13539",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: c.type",
    "difficulty": "simple"
  },
  {
    "idx": 162,
    "db_id": "financial",
    "question": "What is the region of the client with the id 3541 from?",
    "evidence": "A3 refers to region",
    "gold_sql": "SELECT T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
    "predicted_sql": "SELECT \n  d.a3 AS region\nFROM \n  client c\n  INNER JOIN district d ON c.district_id = d.district_id\nWHERE \n  c.client_id = 3541",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 163,
    "db_id": "financial",
    "question": "Which district has the most accounts with loan contracts finished with no problems?",
    "evidence": "status = 'A' refers to loan contracts finished with no problems",
    "gold_sql": "SELECT T1.A2 FROM District AS T1 INNER JOIN Account AS T2 ON T1.District_id = T2.District_id INNER JOIN Loan AS T3 ON T2.Account_id = T3.Account_id WHERE T3.status = 'A' GROUP BY T1.District_id ORDER BY COUNT(T2.Account_id) DESC LIMIT 1",
    "predicted_sql": "SELECT \n  d.a2 AS district_name, \n  COUNT(l.account_id) AS num_loans\nFROM \n  district d \n  JOIN account a ON d.district_id = a.district_id\n  JOIN loan l ON a.account_id = l.account_id\n  JOIN client c ON a.account_id = c.client_id\nWHERE \n  l.status = 'A'\nGROUP BY \n  d.a2\nORDER BY \n  num_loans DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 164,
    "db_id": "financial",
    "question": "Who placed the order with the id 32423?",
    "evidence": "",
    "gold_sql": "SELECT T3.client_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id  INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE T1.order_id = 32423",
    "predicted_sql": "SELECT \n    c.client_id, \n    c.gender, \n    c.birth_date, \n    c.district_id, \n    d.a2, \n    d.a3, \n    d.a4, \n    d.a5, \n    d.a6, \n    d.a7, \n    d.a8, \n    d.a9, \n    d.a10, \n    d.a11, \n    d.a12, \n    d.a13, \n    d.a14, \n    d.a15, \n    d.a16\nFROM \n    client c\nJOIN \n    disp d ON c.client_id = d.client_id\nJOIN \n    account a ON d.account_id = a.account_id\nJOIN \n    order o ON a.account_id = o.account_id\nWHERE \n    o.order_id = 32423",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"order\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 165,
    "db_id": "financial",
    "question": "Please list all the transactions made by accounts from district 5.",
    "evidence": "",
    "gold_sql": "SELECT T3.trans_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T1.district_id = 5",
    "predicted_sql": "SELECT \n  t.trans_id,\n  t.date,\n  t.type,\n  t.operation,\n  t.amount,\n  t.balance,\n  t.k_symbol,\n  t.bank,\n  a.account_id\nFROM \n  trans t\n  JOIN account a ON t.account_id = a.account_id\nWHERE \n  a.district_id = 5",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 166,
    "db_id": "financial",
    "question": "How many of the accounts are from Jesenik district?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A2 = 'Jesenik'",
    "predicted_sql": "SELECT COUNT(DISTINCT a.account_id)\nFROM account a\nJOIN client c ON a.district_id = c.district_id\nJOIN district d ON c.district_id = d.district_id\nWHERE d.a2 = 'Jesenik'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 167,
    "db_id": "financial",
    "question": "List all the clients' IDs whose junior credit cards were issued after 1996.",
    "evidence": "After 1996 means date > = '1997-01-01",
    "gold_sql": "SELECT T2.client_id FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'junior' AND T1.issued >= '1997-01-01'",
    "predicted_sql": "SELECT client.client_id\nFROM client\nJOIN disp ON client.client_id = disp.client_id\nJOIN card ON disp.disp_id = card.disp_id\nWHERE card.type = 'junior' AND card.issued > '1996-01-01'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 168,
    "db_id": "financial",
    "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
    "evidence": "Female refers to gender = 'F'; Woman and female are closed; Average salary can be found in A11",
    "gold_sql": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
    "predicted_sql": "SELECT \n    (COUNT(DISTINCT c.client_id) / \n     (SELECT COUNT(DISTINCT c2.client_id) \n      FROM client c2 \n      JOIN account a2 ON c2.district_id = a2.district_id \n      WHERE a2.date > (SELECT AVG(a3.date) FROM account a3 WHERE a3.district_id = a2.district_id AND a3.frequency = 'M') \n     ) \n    ) * 100 AS percentage\nFROM \n    client c \nJOIN \n    account a ON c.client_id = a.account_id \nJOIN \n    district d ON c.district_id = d.district_id \nWHERE \n    d.a11 > 10000 AND c.gender = 'F'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 169,
    "db_id": "financial",
    "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
    "evidence": "Growth rate = (sum of amount_1997 - sum of amount_1996) / (sum of amount_1996) * 100%; Male refers to gender = 'M'",
    "gold_sql": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
    "predicted_sql": "SELECT \n    (SUM(CASE WHEN date_part('year', date) = 1997 THEN amount ELSE 0 END) - \n     SUM(CASE WHEN date_part('year', date) = 1996 THEN amount ELSE 0 END)) / \n    SUM(CASE WHEN date_part('year', date) = 1996 THEN amount ELSE 0 END) * 100 AS growth_rate\nFROM \n    loan\nWHERE \n    client_id IN (SELECT client_id FROM client WHERE gender = 'M')\nAND \n    date_part('year', date) IN (1996, 1997)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: date_part",
    "difficulty": "challenging"
  },
  {
    "idx": 170,
    "db_id": "financial",
    "question": "How many credit card withdrawals were recorded after 1995?",
    "evidence": "Operation = 'VYBER KARTOU' means credit card withdrawals",
    "gold_sql": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
    "predicted_sql": "SELECT COUNT(*)\nFROM trans\nWHERE operation = 'VYBER KARTOU'\nAND DATE(trans.date) > '1995-01-01'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 171,
    "db_id": "financial",
    "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
    "evidence": "Difference in no. of committed crimes between 2 regions = Total no. of committed crimes in 1996 in north Bohemia - Total no. of committed crimes in 1996 in e ast Bohemia. A3 refers to region. Data about no. of committed crimes 1996 appears in A16",
    "gold_sql": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
    "predicted_sql": "SELECT \n  (SELECT SUM(a16) FROM financial.district WHERE a3 = 'North Bohemia') - \n  (SELECT SUM(a16) FROM financial.district WHERE a3 = 'East Bohemia') AS difference_in_crimes",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: financial.district",
    "difficulty": "moderate"
  },
  {
    "idx": 172,
    "db_id": "financial",
    "question": "How many owner and disponent dispositions are there from account number 1 to account number 10?",
    "evidence": "",
    "gold_sql": "SELECT SUM(type = 'OWNER') , SUM(type = 'DISPONENT') FROM disp WHERE account_id BETWEEN 1 AND 10",
    "predicted_sql": "SELECT \n  COUNT(DISTINCT disp.disp_id) AS total_dispositions,\n  COUNT(CASE WHEN disp.type = 'owner' THEN 1 ELSE NULL END) AS owner_dispositions,\n  COUNT(CASE WHEN disp.type = 'disponent' THEN 1 ELSE NULL END) AS disponent_dispositions\nFROM \n  financial.disp\nWHERE \n  client.client_id IN (SELECT account.client_id FROM financial.account WHERE account_id BETWEEN 1 AND 10)\nORDER BY \n  total_dispositions DESC",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: financial.disp",
    "difficulty": "simple"
  },
  {
    "idx": 173,
    "db_id": "financial",
    "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
    "evidence": "k_symbol refers to the purpose of payments",
    "gold_sql": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
    "predicted_sql": "SELECT \n    COUNT(*) AS frequency,\n    SUM(CASE WHEN k_symbol = '3539' THEN amount ELSE 0 END) AS total_debit\nFROM \n    trans\nWHERE \n    account_id = 3 AND type ='statement_request'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 174,
    "db_id": "financial",
    "question": "What year was account owner number 130 born?",
    "evidence": "",
    "gold_sql": "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130",
    "predicted_sql": "SELECT EXTRACT(YEAR FROM birth_date) AS birth_year\nFROM client\nWHERE client_id = 130",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"FROM\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 175,
    "db_id": "financial",
    "question": "How many accounts have an owner disposition and request for a statement to be generated upon a transaction?",
    "evidence": "Frequency = 'POPLATEK PO OBRATU' stands for issuance after transaction",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'",
    "predicted_sql": "SELECT \n  COUNT(DISTINCT a.account_id) \nFROM \n  account a \n  JOIN disp d ON a.account_id = d.account_id \n  JOIN client c ON d.client_id = c.client_id \n  JOIN district district ON c.district_id = district.district_id \nWHERE \n  d.disp_id IS NOT NULL \n  AND a.frequency = 'POPLATEK PO OBRATU'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 176,
    "db_id": "financial",
    "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
    "evidence": "",
    "gold_sql": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
    "predicted_sql": "SELECT \n    SUM(loan.amount) AS total_debt,\n    (SELECT \n         SUM(payments) \n     FROM \n         loan \n     WHERE \n         account_id IN (SELECT \n                              account_id \n                          FROM \n                              disp \n                          WHERE \n                              client_id = 992)) AS total_payments\nFROM \n    loan \nWHERE \n    account_id IN (SELECT \n                         account_id \n                     FROM \n                         disp \n                     WHERE \n                         client_id = 992)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 177,
    "db_id": "financial",
    "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
    "evidence": "",
    "gold_sql": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
    "predicted_sql": "SELECT \n    SUM(t.amount) AS total_amount\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nJOIN \n    client c ON a.client_id = c.client_id\nWHERE \n    t.trans_id = 851\n    AND c.client_id = 4",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.client_id",
    "difficulty": "simple"
  },
  {
    "idx": 178,
    "db_id": "financial",
    "question": "Which kind of credit card does client number 9 possess?",
    "evidence": "",
    "gold_sql": "SELECT T3.type FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.client_id = 9",
    "predicted_sql": "SELECT type\nFROM card\nWHERE disp_id IN (\n  SELECT disp_id\n  FROM disp\n  WHERE client_id = 9\n)",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 179,
    "db_id": "financial",
    "question": "How much, in total, did client number 617 pay for all of the transactions in 1998?",
    "evidence": "",
    "gold_sql": "SELECT SUM(T3.amount) FROM client AS T1 INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date)= '1998' AND T1.client_id = 617",
    "predicted_sql": "SELECT SUM(t.amount) \nFROM trans t, client c \nWHERE t.account_id = c.client_id AND c.client_id = 617 AND EXTRACT(YEAR FROM t.date) = 1998",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"FROM\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 180,
    "db_id": "financial",
    "question": "Please provide a list of clients who were born between 1983 and 1987 and whose account branch is in East Bohemia, along with their IDs.",
    "evidence": "",
    "gold_sql": "SELECT T1.client_id, T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id and T4.account_id = T3.account_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'",
    "predicted_sql": "SELECT c.client_id, c.client_id AS client_id\nFROM client c\nJOIN account a ON c.district_id = a.district_id\nJOIN district d ON a.district_id = d.district_id\nWHERE c.birth_date BETWEEN '1983-01-01' AND '1987-12-31'\nAND d.a2 = 'East Bohemia'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 181,
    "db_id": "financial",
    "question": "Please provide the IDs of the 3 female clients with the largest loans.",
    "evidence": "Female refers to gender = 'F'",
    "gold_sql": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T4 on T1.client_id= T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id  INNER JOIN loan AS T3 ON T2.account_id = T3.account_id and T4.account_id = T3.account_id WHERE T1.gender = 'F' ORDER BY T3.amount DESC LIMIT 3",
    "predicted_sql": "SELECT \n    client.client_id\nFROM \n    client\nWHERE \n    client.gender = 'F'\nORDER BY \n    (SELECT SUM(loan.amount) FROM loan WHERE loan.account_id = client.account_id)\nDESC \nLIMIT 3",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: client.account_id",
    "difficulty": "simple"
  },
  {
    "idx": 182,
    "db_id": "financial",
    "question": "How many male customers who were born between 1974 and 1976 have made a payment on their home in excess of $4000?",
    "evidence": "Man and male refers to gender = 'M'; 'SIPO' stands for household payment",
    "gold_sql": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T2.account_id = T4.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976' AND T3.gender = 'M' AND T1.amount > 4000 AND T1.k_symbol = 'SIPO'",
    "predicted_sql": "SELECT COUNT(*)\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'M'\nAND c.birth_date BETWEEN '1974-01-01' AND '1976-12-31'\nAND l.amount > 4000",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 183,
    "db_id": "financial",
    "question": "How many accounts in Beroun were opened after 1996?",
    "evidence": "",
    "gold_sql": "SELECT COUNT(account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) > '1996' AND T2.A2 = 'Beroun'",
    "predicted_sql": "SELECT COUNT(*)\nFROM account\nWHERE district_id IN (\n  SELECT district_id\n  FROM district\n  WHERE a2 = 'Beroun'\n) AND date > '1996-01-01'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 184,
    "db_id": "financial",
    "question": "How many female customers have a junior credit card?",
    "evidence": "Female refers to gender = 'F'",
    "gold_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
    "predicted_sql": "SELECT COUNT(DISTINCT c.client_id)\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE c.gender = 'F' AND ca.type = 'J'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 185,
    "db_id": "financial",
    "question": "What proportion of customers who have accounts at the Prague branch are female?",
    "evidence": "Female refers to gender = 'F'; Percentage of female clients in Prague branch = count[female clients with accounts in Prague branch / count(clients with accounts in Prague branch)] * 100%; A3 may contain information about Prague",
    "gold_sql": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'Prague'",
    "predicted_sql": "SELECT \n    (COUNT(DISTINCT c.client_id) \n     WHERE c.district_id = \n         (SELECT d.district_id \n          FROM district d \n          WHERE d.a3 LIKE '%Prague%')\n     AND c.gender = 'F') \n     * 100.0 / \n     (COUNT(DISTINCT c.client_id) \n      WHERE c.district_id = \n         (SELECT d.district_id \n          FROM district d \n          WHERE d.a3 LIKE '%Prague%'))\nAS percentage_of_female_customers\nFROM client c",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"WHERE\": syntax error",
    "difficulty": "moderate"
  },
  {
    "idx": 186,
    "db_id": "financial",
    "question": "What percentage of male clients request for weekly statements to be issued?",
    "evidence": "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
    "gold_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
    "predicted_sql": "SELECT \n  (COUNT(CASE WHEN gender = 'M' AND frequency = 'POPLATEK TYDNE' THEN 1 ELSE NULL END) / \n   COUNT(CASE WHEN frequency = 'POPLATEK TYDNE' THEN 1 ELSE NULL END)) * 100 AS percentage\nFROM \n  client\n  JOIN account ON client.client_id = account.client_id\nWHERE \n  account.frequency = 'POPLATEK TYDNE'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: account.client_id",
    "difficulty": "moderate"
  },
  {
    "idx": 187,
    "db_id": "financial",
    "question": "How many clients who choose statement of weekly issuance are Owner?",
    "evidence": "Frequency = 'POPLATEK TYDNE' refers to weekly issuance",
    "gold_sql": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
    "predicted_sql": "SELECT COUNT(DISTINCT c.client_id) \nFROM client c, disp d, account a \nWHERE c.district_id = d.district_id \nAND d.account_id = a.account_id \nAND a.frequency = 'POPLATEK TYDNE' \nAND c.gender = 'Owner'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: d.district_id",
    "difficulty": "simple"
  },
  {
    "idx": 188,
    "db_id": "financial",
    "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
    "evidence": "",
    "gold_sql": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
    "predicted_sql": "SELECT \n    a.account_id, \n    a.date, \n    l.amount AS approved_amount\nFROM \n    account a \nJOIN \n    loan l ON a.account_id = l.account_id \nWHERE \n    l.duration > 24 AND a.date < '1997-01-01'\nORDER BY \n    approved_amount ASC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 189,
    "db_id": "financial",
    "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
    "evidence": "Female refers to 'F' in the gender; A11 contains information about average salary",
    "gold_sql": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
    "predicted_sql": "SELECT a.account_id\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'F' AND a11 = (SELECT MIN(a11) FROM district)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.account_id",
    "difficulty": "moderate"
  },
  {
    "idx": 190,
    "db_id": "financial",
    "question": "How many clients who were born in 1920 stay in east Bohemia?",
    "evidence": "East Bohemia appears in the column A3, which refers to the region.",
    "gold_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
    "predicted_sql": "SELECT COUNT(DISTINCT c.client_id)\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.birth_date LIKE '%1920%' AND d.a3 = 'East Bohemia'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 191,
    "db_id": "financial",
    "question": "How many loan accounts are for pre-payment of duration of 24 months with weekly issuance of statement.",
    "evidence": "Frequency = 'POPLATEK TYDNE' referes to weekly statement",
    "gold_sql": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.duration = 24 AND T1.frequency = 'POPLATEK TYDNE'",
    "predicted_sql": "SELECT COUNT(*)\nFROM account\nJOIN disp ON account.account_id = disp.account_id\nJOIN client ON disp.client_id = client.client_id\nJOIN loan ON account.account_id = loan.account_id\nWHERE frequency = 'POPLATEK TYDNE'\nAND duration = 24\nAND status = 'active'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 192,
    "db_id": "financial",
    "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
    "evidence": "status = 'C' stands for running contract, OK so far; status = 'D' stands for running contract, client in debt. 'POPLATEK PO OBRATU' stands for issuance after transaction",
    "gold_sql": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
    "predicted_sql": "SELECT AVG(amount) \nFROM loan \nWHERE status = 'C' \nAND k_symbol = 'POPLATEK PO OBRATU'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: k_symbol",
    "difficulty": "moderate"
  },
  {
    "idx": 193,
    "db_id": "financial",
    "question": "List all ID and district for clients that can only have the right to issue permanent orders or apply for loans.",
    "evidence": "Only the owner accounts have the right to issue permanent orders or apply for loans",
    "gold_sql": "SELECT T3.client_id, T2.district_id, T2.A2 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE T3.type = 'OWNER'",
    "predicted_sql": "SELECT \n  c.client_id, \n  d.a2 AS district\nFROM \n  client c \n  JOIN district d ON c.district_id = d.district_id\nWHERE \n  (c.client_id NOT IN (SELECT account_id FROM disp WHERE type = 'credit')) \n  AND (c.client_id NOT IN (SELECT account_id FROM loan WHERE status = 'active'))",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 194,
    "db_id": "financial",
    "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
    "evidence": "the credit card is high-level refers to card.type = 'gold'; eligible for loans refers to disp.type = 'OWNER'",
    "gold_sql": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
    "predicted_sql": "SELECT \n    c.client_id, \n    DATE_PART('year', age(c.birth_date)) AS age\nFROM \n    client c\nJOIN \n    disp d ON c.client_id = d.client_id\nJOIN \n    card ca ON d.disp_id = ca.disp_id\nWHERE \n    ca.type = 'gold' AND d.type = 'OWNER'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DATE_PART",
    "difficulty": "moderate"
  },
  {
    "idx": 195,
    "db_id": "toxicology",
    "question": "What is the most common bond type?",
    "evidence": "most common bond type refers MAX(COUNT(bond_type))",
    "gold_sql": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
    "predicted_sql": "SELECT \n  b.bond_type, \n  COUNT(b.bond_type) AS count\nFROM \n  bond b\nGROUP BY \n  b.bond_type\nORDER BY \n  count DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 196,
    "db_id": "toxicology",
    "question": "In the non-carcinogenic molecules, how many contain chlorine atoms?",
    "evidence": "non-carcinogenic molecules refers to label = '-'; chlorine atoms refers to element = 'cl'",
    "gold_sql": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl' AND T1.label = '-'",
    "predicted_sql": "SELECT COUNT(*) \nFROM molecule \nJOIN atom ON molecule.molecule_id = atom.molecule_id \nWHERE molecule.label = '-' AND element = 'cl'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 197,
    "db_id": "toxicology",
    "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
    "evidence": "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')",
    "gold_sql": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
    "predicted_sql": "SELECT AVG(CASE WHEN element = 'o' THEN 1 ELSE 0 END) AS avg_oxygen\nFROM (\n  SELECT atom_id\n  FROM connected\n  JOIN atom ON connected.atom_id = atom.atom_id\n  JOIN bond ON connected.atom_id2 = bond.atom_id\n  WHERE bond.bond_type = '-'\n) AS single_bonded_atoms\nJOIN atom ON single_bonded_atoms.atom_id = atom.atom_id",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: ambiguous column name: atom_id",
    "difficulty": "moderate"
  },
  {
    "idx": 198,
    "db_id": "toxicology",
    "question": "On average how many carcinogenic molecules are single bonded?",
    "evidence": "carcinogenic molecules refers to label = '+'; single-bonded refers to bond_type = '-'; average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))",
    "gold_sql": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
    "predicted_sql": "SELECT \n    AVG(DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))) AS average_single_bonded_carcinogenic\nFROM \n    (\n        SELECT \n            molecule_id, \n            COUNT(*) AS atom_id\n        FROM \n            atom\n        WHERE \n            element IN (\n                SELECT \n                    element \n                FROM \n                    atom \n                WHERE \n                    molecule_id IN (\n                        SELECT \n                            molecule_id \n                        FROM \n                            molecule \n                        WHERE \n                            label = '+'\n                    )\n            )\n        GROUP BY \n            molecule_id\n    ) AS molecule_atoms\nJOIN \n    bond ON molecule_atoms.molecule_id = bond.molecule_id\nWHERE \n    bond_type = '-'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: misuse of aggregate function COUNT()",
    "difficulty": "challenging"
  },
  {
    "idx": 199,
    "db_id": "toxicology",
    "question": "In the molecule containing sodium atoms, how many are non-carcinogenic?",
    "evidence": "non-carcinogenic refers to label = '-'; sodium atoms refers to element = 'na'",
    "gold_sql": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'",
    "predicted_sql": "SELECT COUNT(*)\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id\nWHERE a.element = 'na' AND m.label = '-'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 200,
    "db_id": "toxicology",
    "question": "Find the triple-bonded molecules which are carcinogenic.",
    "evidence": "triple-bonded molecules refers to bond_type = '#'; carcinogenic refers to label = '+'",
    "gold_sql": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
    "predicted_sql": "SELECT m.label\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a ON c.atom_id = a.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '#' AND m.label = '+'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 201,
    "db_id": "toxicology",
    "question": "What is the percentage of carbon in double-bond molecules?",
    "evidence": "carbon refers to element = 'c'; double-bond molecules refers to bond_type = '='; percentage = DIVIDE(SUM(element = 'c'), COUNT(atom_id))",
    "gold_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
    "predicted_sql": "SELECT \n    DIVIDE(SUM(CASE WHEN element = 'c' THEN 1 ELSE 0 END), COUNT(atom_id)) AS percentage\nFROM \n    atom\nJOIN \n    bond ON atom.molecule_id = bond.molecule_id\nWHERE \n    bond.bond_type = '='",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "moderate"
  },
  {
    "idx": 202,
    "db_id": "toxicology",
    "question": "How many triple type bonds are there?",
    "evidence": "triple type bonds refers to bond_type = '#'",
    "gold_sql": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '#'",
    "predicted_sql": "SELECT COUNT(*) \nFROM bond \nWHERE bond_type = '#'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 203,
    "db_id": "toxicology",
    "question": "In how many atoms is there no bromine?",
    "evidence": "atoms with no bromine refers to element ! = 'br'",
    "gold_sql": "SELECT COUNT(DISTINCT T.atom_id) FROM atom AS T WHERE T.element <> 'br'",
    "predicted_sql": "SELECT COUNT(*)\nFROM atom\nWHERE element!= 'br'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 204,
    "db_id": "toxicology",
    "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
    "evidence": "first 100 molecules in number order refers to molecule_id between 'TR000' and 'TR099'; label = '+' means molecules are carcinogenic",
    "gold_sql": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
    "predicted_sql": "SELECT COUNT(*)\nFROM molecule\nWHERE molecule_id BETWEEN 'TR000' AND 'TR099'\nAND label = '+'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 205,
    "db_id": "toxicology",
    "question": "Identify by their ID the molecules in which there is carbon.",
    "evidence": "carbon refers to element = 'c';",
    "gold_sql": "SELECT T.molecule_id FROM atom AS T WHERE T.element = 'c'",
    "predicted_sql": "SELECT m.molecule_id\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE a.element = 'c'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 206,
    "db_id": "toxicology",
    "question": "What elements are in the TR004_8_9 bond atoms?",
    "evidence": "TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9';",
    "gold_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
    "predicted_sql": "SELECT \n  a.element \nFROM \n  atom a \n  JOIN connected c ON a.atom_id = c.atom_id \n  JOIN connected c2 ON c.atom_id2 = c2.atom_id \n  JOIN atom a2 ON c2.atom_id = a2.atom_id \nWHERE \n  c.bond_id = 'TR004_8_9' \n  AND a.molecule_id = a2.molecule_id",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "challenging"
  },
  {
    "idx": 207,
    "db_id": "toxicology",
    "question": "What elements are in a double type bond?",
    "evidence": "double type bond refers to bond_type = '=';",
    "gold_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
    "predicted_sql": "SELECT \n  DISTINCT a1.element AS element1, \n  a2.element AS element2\nFROM \n  connected c\n  JOIN bond b ON c.bond_id = b.bond_id\n  JOIN atom a1 ON c.atom_id = a1.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n  b.bond_type = '='",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 208,
    "db_id": "toxicology",
    "question": "Which type of label is the most numerous in atoms with hydrogen?",
    "evidence": "with hydrogen refers to element = 'h'; label most numerous in atoms refers to MAX(COUNT(label)); ",
    "gold_sql": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
    "predicted_sql": "SELECT \n  b.label, \n  COUNT(a.element) \nFROM \n  atom a \n  JOIN molecule b ON a.molecule_id = b.molecule_id \nWHERE \n  a.element = 'H' \nGROUP BY \n  b.label \nORDER BY \n  COUNT(a.element) DESC \nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 209,
    "db_id": "toxicology",
    "question": "Chlorine is in what type of bond?",
    "evidence": "type of bond refers to bond_type; chlorine refers to element = 'cl'",
    "gold_sql": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
    "predicted_sql": "SELECT \n    bond_type\nFROM \n    bond\nWHERE \n    element = 'cl'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: element",
    "difficulty": "simple"
  },
  {
    "idx": 210,
    "db_id": "toxicology",
    "question": "What atoms are connected in single type bonds?",
    "evidence": "single type bond refers to bond_type = '-';",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
    "predicted_sql": "SELECT DISTINCT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id IN (\n  SELECT b.bond_id\n  FROM bond b\n  WHERE b.bond_type = '-'\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 211,
    "db_id": "toxicology",
    "question": "Indicate which atoms are connected in non-carcinogenic type molecules.",
    "evidence": "label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT DISTINCT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.label = '-'",
    "predicted_sql": "SELECT \n  a1.atom_id, a2.atom_id AS connected_atom\nFROM \n  connected c\n  JOIN atom a1 ON c.atom_id = a1.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\n  JOIN molecule m ON a1.molecule_id = m.molecule_id\n  JOIN molecule m2 ON a2.molecule_id = m2.molecule_id\nWHERE \n  m.label = '-' AND m2.label = '-'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 212,
    "db_id": "toxicology",
    "question": "Which element is the least numerous in non-carcinogenic molecules?",
    "evidence": "label = '-' means molecules are non-carcinogenic; least numerous refers to MIN(COUNT(element));",
    "gold_sql": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
    "predicted_sql": "SELECT e.element, COUNT(e.element) AS count\nFROM (\n  SELECT a.element\n  FROM atom a\n  JOIN molecule m ON a.molecule_id = m.molecule_id\n  WHERE m.label = '-'\n  GROUP BY a.element\n) e\nORDER BY count LIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 213,
    "db_id": "toxicology",
    "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
    "evidence": "type of bond refers to bond_type; between the atoms TR004_8 and TR004_20 refers to atom_id = 'TR004_8' AND atom_id2 = 'TR004_20' OR another way around",
    "gold_sql": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
    "predicted_sql": "SELECT \n  b.bond_type\nFROM \n  connected c\n  JOIN bond b ON c.bond_id = b.bond_id\nWHERE \n  (c.atom_id = 'TR004_8' AND c.atom_id2 = 'TR004_20') OR\n  (c.atom_id = 'TR004_20' AND c.atom_id2 = 'TR004_8')",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 214,
    "db_id": "toxicology",
    "question": "What type of label is not on molecules with atoms with tin?",
    "evidence": "tin refers to element ! = 'sn'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
    "predicted_sql": "SELECT \n    label\nFROM \n    molecule\nWHERE \n    molecule_id NOT IN (\n        SELECT \n            m.molecule_id\n        FROM \n            molecule m\n        JOIN \n            atom a ON m.molecule_id = a.molecule_id\n        WHERE \n            a.element = 'Sn' AND \n            m.label IN ('+', '-')\n    )",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 215,
    "db_id": "toxicology",
    "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
    "evidence": "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-'; Should consider the distinct atoms when counting;",
    "gold_sql": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
    "predicted_sql": "SELECT \n  COUNT(DISTINCT a.atom_id) \nFROM \n  atom a \n  JOIN connected c ON a.atom_id = c.atom_id \n  JOIN bond b ON c.bond_id = b.bond_id \n  JOIN atom a2 ON c.atom_id2 = a2.atom_id \n  JOIN molecule m ON a.molecule_id = m.molecule_id \n  JOIN molecule m2 ON a2.molecule_id = m2.molecule_id \nWHERE \n  a.element = 'i' OR a.element ='s' \n  AND b.bond_type = '-'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 216,
    "db_id": "toxicology",
    "question": "Identify all connected atoms with a triple bond.",
    "evidence": "triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
    "predicted_sql": "SELECT \n  a1.element, a2.element\nFROM \n  connected c\n  JOIN atom a1 ON c.atom_id = a1.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\n  JOIN bond b ON c.bond_id = b.bond_id\nWHERE \n  b.bond_type = '#'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 217,
    "db_id": "toxicology",
    "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
    "evidence": "TR181 molecule refers to molecule_id = 'TR181'",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
    "predicted_sql": "SELECT \n  a1.element, \n  a2.element\nFROM \n  connected c \n  JOIN atom a1 ON c.atom_id = a1.atom_id \n  JOIN atom a2 ON c.atom_id2 = a2.atom_id \nWHERE \n  a1.molecule_id IN (SELECT molecule_id FROM molecule WHERE label = 'TR181') \n  AND c.bond_id IN (SELECT bond_id FROM bond WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = 'TR181'))",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 218,
    "db_id": "toxicology",
    "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
    "evidence": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;",
    "gold_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "predicted_sql": "SELECT \n    DIVIDE(SUM(CASE WHEN label = '+' AND NOT EXISTS (SELECT 1 FROM atom WHERE molecule_id = m.molecule_id AND element = 'f') THEN 1 ELSE 0 END), \n           (SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m WHERE label = '+')) * 100\nFROM \n    molecule m\nWHERE \n    label = '+'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "challenging"
  },
  {
    "idx": 219,
    "db_id": "toxicology",
    "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
    "evidence": "label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(bond_type = '#') * 100, COUNT(bond_id)) as percent where label = '+'",
    "gold_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
    "predicted_sql": "SELECT \n  DIVIDE(SUM(CASE WHEN label = '+' AND bond_type = '#' THEN 1 ELSE 0 END) * 100, \n         COUNT(CASE WHEN label = '+' AND bond_type = '#' THEN bond_id ELSE NULL END)) \n  AS percent\nFROM \n  molecule\n  LEFT JOIN connected ON molecule.molecule_id = connected.molecule_id\n  LEFT JOIN bond ON connected.bond_id = bond.bond_id\nWHERE \n  label = '+'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "challenging"
  },
  {
    "idx": 220,
    "db_id": "toxicology",
    "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
    "evidence": "TR000 is the molecule id;",
    "gold_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
    "predicted_sql": "SELECT \n  element \nFROM \n  atom \nWHERE \n  molecule_id = (SELECT molecule_id FROM molecule WHERE label = 'TR000') \nORDER BY \n  element \nLIMIT 3",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 221,
    "db_id": "toxicology",
    "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
    "evidence": "TR001 is the molecule id; TR001_2_6 is the bond id",
    "gold_sql": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
    "predicted_sql": "SELECT \n  a1.element AS element1, \n  a2.element AS element2\nFROM \n  atom a1, \n  atom a2, \n  connected c, \n  bond b\nWHERE \n  a1.atom_id = c.atom_id AND \n  a2.atom_id = c.atom_id2 AND \n  b.bond_id = c.bond_id AND \n  a1.molecule_id = 'TR001' AND \n  b.bond_id = 'TR001_2_6'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 222,
    "db_id": "toxicology",
    "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
    "evidence": "label = '+' means molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; difference = SUBTRACT(SUM(label = '+'), SUM(label = '-'))",
    "gold_sql": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
    "predicted_sql": "SELECT \n  SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) - \n  SUM(CASE WHEN m.label = '-' THEN 1 ELSE 0 END) AS difference\nFROM \n  molecule m",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 223,
    "db_id": "toxicology",
    "question": "What are the atom IDs of the bond TR000_2_5?",
    "evidence": "TR000_2_5 is the bond id",
    "gold_sql": "SELECT T.atom_id FROM connected AS T WHERE T.bond_id = 'TR000_2_5'",
    "predicted_sql": "SELECT a.atom_id\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_id = 'TR000_2_5'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: a.atom_id",
    "difficulty": "simple"
  },
  {
    "idx": 224,
    "db_id": "toxicology",
    "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
    "evidence": "TR000_2 is the atom id; atom ID 2 refers to atom_id2",
    "gold_sql": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
    "predicted_sql": "SELECT bond_id\nFROM connected\nWHERE atom_id2 = (\n  SELECT atom_id\n  FROM atom\n  WHERE molecule_id IN (\n    SELECT molecule_id\n    FROM molecule\n    WHERE label = 'TR000_2'\n  )\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 225,
    "db_id": "toxicology",
    "question": "Please list top five molecules that have double bonds in alphabetical order.",
    "evidence": "double bond refers to bond_type = ' = ';",
    "gold_sql": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
    "predicted_sql": "SELECT \n  m.label\nFROM \n  molecule m\nWHERE \n  m.molecule_id IN (\n    SELECT \n      distinct b.molecule_id\n    FROM \n      bond b\n    WHERE \n      b.bond_type ='= '",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: incomplete input",
    "difficulty": "simple"
  },
  {
    "idx": 226,
    "db_id": "toxicology",
    "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
    "evidence": "double bond refers to bond_type = '='; TR008 is the molecule id; percentage = DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent where molecule_id = 'TR008'",
    "gold_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
    "predicted_sql": "SELECT \n  DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) * 100 AS percent \nFROM \n  bond \nWHERE \n  molecule_id = 'TR008'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "moderate"
  },
  {
    "idx": 227,
    "db_id": "toxicology",
    "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
    "evidence": "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent",
    "gold_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
    "predicted_sql": "SELECT \n  ROUND(DIVIDE(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END), COUNT(molecule_id)), 3) as percent\nFROM \n  molecule",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "simple"
  },
  {
    "idx": 228,
    "db_id": "toxicology",
    "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
    "evidence": "hydrogen refers to element = 'h'; TR206 is the molecule id; percentage = DIVIDE(SUM(element = 'h'), COUNT(atom_id)) as percent where molecule_id = 'TR206'",
    "gold_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id),4) FROM atom AS T WHERE T.molecule_id = 'TR206'",
    "predicted_sql": "SELECT \n  DIVIDE(SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END), COUNT(atom_id)) * 100 AS percent\nFROM \n  atom\nWHERE \n  molecule_id = 'TR206'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "moderate"
  },
  {
    "idx": 229,
    "db_id": "toxicology",
    "question": "What is the type of bond that molecule TR000 has when involved in any bonds?",
    "evidence": "type of bond refers to bond_type; TR000 is the molecule id",
    "gold_sql": "SELECT DISTINCT T.bond_type FROM bond AS T WHERE T.molecule_id = 'TR000'",
    "predicted_sql": "SELECT \n  b.bond_type\nFROM \n  bond b\n  JOIN connected c ON b.bond_id = c.bond_id\n  JOIN atom a1 ON c.atom_id = a1.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\n  JOIN molecule m ON a1.molecule_id = m.molecule_id\nWHERE \n  m.molecule_id = 'TR000'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 230,
    "db_id": "toxicology",
    "question": "What are the elements of the toxicology and label of molecule TR060?",
    "evidence": "TR060 is the molecule id; ",
    "gold_sql": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
    "predicted_sql": "SELECT a.element, m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.molecule_id = (SELECT molecule_id FROM molecule WHERE label = 'TR060')",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 231,
    "db_id": "toxicology",
    "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
    "evidence": "TR010 is the molecule id; majority of the bond found refers to MAX(COUNT(bond_type)); ",
    "gold_sql": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
    "predicted_sql": "SELECT \n  bond_type, \n  COUNT(*) AS bond_count, \n  (SELECT COUNT(*) FROM bond WHERE molecule_id = 'TR010') AS total_bonds\nFROM \n  bond\nWHERE \n  molecule_id = 'TR010'\nGROUP BY \n  bond_type\nORDER BY \n  bond_count DESC\nLIMIT 1",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 232,
    "db_id": "toxicology",
    "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
    "evidence": "label = '-' means molecules are not carcinogenic; single type bond refers to bond_type = '-'; list top three molecules refers to return molecule_id and order by molecule_id;",
    "gold_sql": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
    "predicted_sql": "SELECT m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id\nJOIN connected c2 ON a.atom_id = c2.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id AND c2.bond_id = b.bond_id\nWHERE b.bond_type = '-' AND m.label!= '-'\nORDER BY m.label\nLIMIT 3",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 233,
    "db_id": "toxicology",
    "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
    "evidence": "TR006 is the molecule id",
    "gold_sql": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
    "predicted_sql": "SELECT \n  b.bond_type, \n  COUNT(*) AS bond_count\nFROM \n  connected c \n  JOIN bond b ON c.bond_id = b.bond_id \n  JOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE \n  m.molecule_id = 'TR006'\nGROUP BY \n  b.bond_type\nORDER BY \n  bond_count DESC\nLIMIT 2",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 234,
    "db_id": "toxicology",
    "question": "How many bonds which involved atom 12 does molecule TR009 have?",
    "evidence": "TR009 is the molecule id;  involved atom 12 refers to atom_id = 'TR009_12' or atom_id2 = 'TR009_12'",
    "gold_sql": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'",
    "predicted_sql": "SELECT COUNT(b.bond_id)\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE c.atom_id = 'TR009_12' OR c.atom_id2 = 'TR009_12'\nAND b.molecule_id = 'TR009'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 235,
    "db_id": "toxicology",
    "question": "How many molecules are carcinogenic and have the bromine element?",
    "evidence": "label = '+' mean molecules are carcinogenic; have bromine element refers to element = 'br'",
    "gold_sql": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'br'",
    "predicted_sql": "SELECT COUNT(DISTINCT m.molecule_id)\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE a.element = 'br' AND m.label = '+'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 236,
    "db_id": "toxicology",
    "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
    "evidence": "atoms refer to atom_id or atom_id2",
    "gold_sql": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
    "predicted_sql": "SELECT \n  b.bond_type, \n  c.atom_id, \n  c.atom_id2\nFROM \n  bond b\n  JOIN connected c ON b.bond_id = c.bond_id\nWHERE \n  b.molecule_id IN (\n    SELECT \n      m.molecule_id\n    FROM \n      molecule m\n    WHERE \n      m.label = 'TR001_6_9'\n  )",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 237,
    "db_id": "toxicology",
    "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
    "evidence": "TR001_10 is the atom id; label = '+' mean molecules are carcinogenic",
    "gold_sql": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
    "predicted_sql": "SELECT m.label, \n       CASE \n         WHEN m.label = '+' THEN 'carcinogenic'\n         ELSE 'not carcinogenic'\n       END AS carcinogenic_status\nFROM \n  atom a\n  JOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE \n  a.atom_id = 'TR001_10'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 238,
    "db_id": "toxicology",
    "question": "How many molecules have a triple bond type?",
    "evidence": "triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'",
    "predicted_sql": "SELECT COUNT(*) FROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = '#'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 239,
    "db_id": "toxicology",
    "question": "How many connections does the atom 19 have?",
    "evidence": "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';",
    "gold_sql": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
    "predicted_sql": "SELECT COUNT(*)\nFROM connected\nWHERE atom_id = 'TR%_19'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 240,
    "db_id": "toxicology",
    "question": "List all the elements of the toxicology of the molecule \"TR004\".",
    "evidence": "TR004 is the molecule id;",
    "gold_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
    "predicted_sql": "SELECT\n    DISTINCT\n    a.element\nFROM\n    atom a\nWHERE\n    a.molecule_id = (SELECT\n        m.molecule_id\n    FROM\n        molecule m\n    WHERE\n        m.label = 'TR004')\nORDER BY\n    a.element",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 241,
    "db_id": "toxicology",
    "question": "How many of the molecules are not carcinogenic?",
    "evidence": "label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '-'",
    "predicted_sql": "SELECT COUNT(*)\nFROM molecule\nWHERE label = '-'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 242,
    "db_id": "toxicology",
    "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
    "evidence": "atoms from 21 to 25 refers to SUBSTR(atom_id, 7, 2) between '21' and '25'; label = '+' mean molecules are carcinogenic",
    "gold_sql": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
    "predicted_sql": "SELECT DISTINCT m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE a.element IN (SELECT element FROM atom WHERE SUBSTR(atom_id, 7, 2) BETWEEN '21' AND '25')\nAND m.label = '+'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 243,
    "db_id": "toxicology",
    "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
    "evidence": "have phosphorus as atom elements refers to element = 'p'; have nitrogen as atom elements refers to element = 'n'",
    "gold_sql": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
    "predicted_sql": "SELECT b.bond_id, a1.element AS atom1, a2.element AS atom2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE a1.element = 'p' AND a2.element = 'n'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 244,
    "db_id": "toxicology",
    "question": "Is the molecule with the most double bonds carcinogenic?",
    "evidence": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic",
    "gold_sql": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
    "predicted_sql": "SELECT m.label\nFROM molecule m\nJOIN (\n  SELECT molecule_id, COUNT(*) AS num_double_bonds\n  FROM bond\n  WHERE bond_type ='= '\n  GROUP BY molecule_id\n  ORDER BY num_double_bonds DESC\n  LIMIT 1\n) AS double_bonds ON m.molecule_id = double_bonds.molecule_id\nWHERE m.label = '+'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 245,
    "db_id": "toxicology",
    "question": "What is the average number of bonds the atoms with the element iodine have?",
    "evidence": "atoms with the element iodine refers to element = 'i'; average = DIVIDE(COUND(bond_id), COUNT(atom_id)) where element = 'i'",
    "gold_sql": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
    "predicted_sql": "SELECT \n  AVG(DIVIDE(COUNT(bond_id), COUNT(atom_id))) AS avg_bonds \nFROM \n  connected \nWHERE \n  element = 'i'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: misuse of aggregate function COUNT()",
    "difficulty": "moderate"
  },
  {
    "idx": 246,
    "db_id": "toxicology",
    "question": "List the bond type and the bond ID of the atom 45.",
    "evidence": "bond ID of atom 45 refers to SUBSTR(atom_id, 7, 2) + 0 = 45; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE SUBSTR(T2.atom_id, 7, 2) = '45'",
    "predicted_sql": "SELECT \n    b.bond_type, \n    b.bond_id\nFROM \n    bond b\nJOIN \n    connected c ON b.bond_id = c.bond_id\nWHERE \n    c.atom_id = 45",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 247,
    "db_id": "toxicology",
    "question": "List all the elements of atoms that can not bond with any other atoms.",
    "evidence": " atoms cannot bond with other atoms means atom_id NOT in connected table;",
    "gold_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
    "predicted_sql": "SELECT DISTINCT a.element \nFROM atom a \nWHERE NOT EXISTS (\n  SELECT 1 \n  FROM connected c \n  WHERE c.atom_id = a.atom_id \n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 248,
    "db_id": "toxicology",
    "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
    "evidence": "TR041 is the molecule id; triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
    "predicted_sql": "SELECT a.element\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id\nJOIN connected c2 ON c.atom_id2 = c2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id AND c2.bond_id = b.bond_id\nWHERE a.molecule_id = (SELECT molecule_id FROM molecule WHERE label = 'TR041') AND b.bond_type = '#'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 249,
    "db_id": "toxicology",
    "question": "What are the elements of the atoms of TR144_8_19?",
    "evidence": "TR144_8_19 is the bond id; ",
    "gold_sql": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
    "predicted_sql": "SELECT \n    a.element\nFROM \n    atom a\nWHERE \n    a.molecule_id IN (\n        SELECT \n            m.molecule_id\n        FROM \n            molecule m\n        WHERE \n            m.label = 'TR144_8_19'\n    )\nORDER BY \n    a.element",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 250,
    "db_id": "toxicology",
    "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
    "evidence": "label = '+' mean molecules are carcinogenic; double bond refers to bond_type = ' = ';",
    "gold_sql": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
    "predicted_sql": "SELECT \n  m.label, \n  COUNT(b.bond_type) AS double_bonds\nFROM \n  molecule m\n  JOIN connected c ON m.molecule_id = c.molecule_id\n  JOIN bond b ON c.bond_id = b.bond_id\nWHERE \n  m.label = '+'\n  AND b.bond_type ='= '\nGROUP BY \n  m.label\nORDER BY \n  double_bonds DESC\nLIMIT 1",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: c.molecule_id",
    "difficulty": "moderate"
  },
  {
    "idx": 251,
    "db_id": "toxicology",
    "question": "What is the least common element of all carcinogenic molecules?",
    "evidence": "label = '+' mean molecules are carcinogenic",
    "gold_sql": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
    "predicted_sql": "SELECT e.element\nFROM (\n  SELECT e.element, COUNT(*) as count\n  FROM molecule m\n  JOIN atom a ON m.molecule_id = a.molecule_id\n  JOIN (\n    SELECT molecule_id\n    FROM molecule\n    WHERE label = '+'\n  ) cm ON m.molecule_id = cm.molecule_id\n  JOIN (\n    SELECT DISTINCT element\n    FROM atom\n    WHERE molecule_id IN (\n      SELECT molecule_id\n      FROM molecule\n      WHERE label = '+'\n    )\n  ) e ON a.element = e.element\n  GROUP BY e.element\n  ORDER BY count\n) t\nWHERE count = (SELECT MIN(count) FROM t)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such table: t",
    "difficulty": "moderate"
  },
  {
    "idx": 252,
    "db_id": "toxicology",
    "question": "What are the atoms that can bond with the atom that has the element lead?",
    "evidence": "atom that has the element lead refers to atom_id where element = 'pb'",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
    "predicted_sql": "SELECT DISTINCT a2.atom_id\nFROM connected c\nJOIN atom a ON a.atom_id = c.atom_id\nJOIN atom a2 ON a2.atom_id = c.atom_id2\nWHERE a.element = 'pb'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 253,
    "db_id": "toxicology",
    "question": "List the elements of all the triple bonds.",
    "evidence": "triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
    "predicted_sql": "SELECT \n  a.element\nFROM \n  connected c \n  JOIN bond b ON c.bond_id = b.bond_id \n  JOIN atom a ON c.atom_id = a.atom_id \nWHERE \n  b.bond_type = '#'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "challenging"
  },
  {
    "idx": 254,
    "db_id": "toxicology",
    "question": "What percentage of bonds have the most common combination of atoms' elements?",
    "evidence": "DIVIDE(COUNT(bond_id), COUNT(atom_id where MAX(COUNT(atom_id)) ))",
    "gold_sql": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
    "predicted_sql": "SELECT \n  (COUNT(bond_id) / \n   (SELECT COUNT(atom_id) \n    FROM (SELECT atom_id, COUNT(*) as count \n          FROM connected \n          GROUP BY atom_id) as t \n    WHERE count = (SELECT MAX(count) FROM (SELECT atom_id, COUNT(*) as count \n                                             FROM connected \n                                             GROUP BY atom_id) as t2)) \n  ) * 100 AS percentage",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: bond_id",
    "difficulty": "moderate"
  },
  {
    "idx": 255,
    "db_id": "toxicology",
    "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
    "evidence": "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'",
    "gold_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
    "predicted_sql": "SELECT \n  ROUND(DIVIDE(SUM(CASE WHEN bond_type = '-' AND label = '+' THEN 1 ELSE 0 END) * 100, \n                COUNT(bond_type = '-')), 5) \nFROM \n  bond \n  LEFT JOIN connected ON bond.bond_id = connected.bond_id \n  LEFT JOIN atom ON connected.atom_id = atom.atom_id \n  LEFT JOIN atom AS atom2 ON connected.atom_id2 = atom2.atom_id \n  LEFT JOIN molecule ON atom.molecule_id = molecule.molecule_id \n  AND atom2.molecule_id = molecule.molecule_id",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "moderate"
  },
  {
    "idx": 256,
    "db_id": "toxicology",
    "question": "Calculate the total atoms consisting of the element carbon and hydrogen.",
    "evidence": "consisting of element carbon and hydrogen refers to element in('c', 'h')",
    "gold_sql": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'",
    "predicted_sql": "SELECT \n    SUM(CASE WHEN element IN ('C', 'H') THEN 1 ELSE 0 END) AS total_carbon_hydrogen_atoms\nFROM \n    atom\nWHERE \n    molecule_id IN (SELECT molecule_id FROM molecule WHERE label LIKE '%consisting%of%element%carbon%and%hydrogen%refers%to%element%in%\\'c\\',\\'h\\'%')",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"c\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 257,
    "db_id": "toxicology",
    "question": "List down atom id2 for atoms with element sulfur.",
    "evidence": "element sulfur refers to element = 's'",
    "gold_sql": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
    "predicted_sql": "SELECT c.atom_id2\nFROM connected c\nJOIN atom a ON c.atom_id = a.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element ='s'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 258,
    "db_id": "toxicology",
    "question": "What are the bond type for atoms with element Tin?",
    "evidence": "element Tin refers to element = 'sn'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#'",
    "gold_sql": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
    "predicted_sql": "SELECT \n  b.bond_type, \n  COUNT(*) AS count\nFROM \n  connected c \n  JOIN bond b ON c.bond_id = b.bond_id \n  JOIN atom a ON c.atom_id = a.atom_id \n  JOIN atom a2 ON c.atom_id2 = a2.atom_id \nWHERE \n  a.element ='sn' \n  AND a2.element ='sn'\nGROUP BY \n  b.bond_type",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 259,
    "db_id": "toxicology",
    "question": "How many elements are there for single bond molecules?",
    "evidence": "single bond refers to bond_type = '-';",
    "gold_sql": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
    "predicted_sql": "SELECT COUNT(DISTINCT e.element) \nFROM \n  molecule m \n  JOIN atom a ON m.molecule_id = a.molecule_id \n  JOIN bond b ON a.atom_id = b.atom_id \n  JOIN connected c ON a.atom_id = c.atom_id \n  JOIN connected c2 ON c.atom_id2 = c2.atom_id2 \n  JOIN atom a2 ON c2.atom_id = a2.atom_id \n  JOIN bond b2 ON a2.atom_id = b2.atom_id \n  JOIN connected c3 ON a2.atom_id = c3.atom_id \n  JOIN connected c4 ON c3.atom_id2 = c4.atom_id2 \n  JOIN atom a4 ON c4.atom_id = a4.atom_id \n  JOIN bond b4 ON a4.atom_id = b4.atom_id \n  JOIN connected c5 ON a4.atom_id = c5.atom_id \n  JOIN connected c6 ON c5.atom_id2 = c6.atom_id2 \n  JOIN atom a6 ON c6.atom_id = a6.atom_id \n  JOIN bond b6 ON a6.atom_id = b6.atom_id \n  JOIN connected c7 ON a6.atom_id = c7.atom_id",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: e.element",
    "difficulty": "simple"
  },
  {
    "idx": 260,
    "db_id": "toxicology",
    "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
    "evidence": "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'",
    "gold_sql": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
    "predicted_sql": "SELECT COUNT(DISTINCT a.atom_id)\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nJOIN bond b ON a.molecule_id = b.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id\nJOIN connected c2 ON a.atom_id = c2.atom_id2\nJOIN bond b2 ON c2.bond_id = b2.bond_id\nWHERE b.bond_type = '#' AND (a.element = 'p' OR a.element = 'br')",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 261,
    "db_id": "toxicology",
    "question": "Write down bond id for molecules that are carcinogenic.",
    "evidence": "label = '+' mean molecules are carcinogenic",
    "gold_sql": "SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "predicted_sql": "SELECT bond_id FROM bond WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+')",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 262,
    "db_id": "toxicology",
    "question": "Among the single bond molecule id, which molecules are not carcinogenic?",
    "evidence": "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';",
    "gold_sql": "SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
    "predicted_sql": "SELECT \n  m.molecule_id, \n  m.label\nFROM \n  molecule m\nWHERE \n  m.label!= '-' \n  AND NOT EXISTS (\n    SELECT \n      1\n    FROM \n      bond b\n      JOIN connected c ON b.bond_id = c.bond_id\n    WHERE \n      b.molecule_id = m.molecule_id \n      AND b.bond_type = '-'\n  )",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 263,
    "db_id": "toxicology",
    "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
    "evidence": "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'",
    "gold_sql": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
    "predicted_sql": "SELECT \n  DIVIDE(SUM(CASE WHEN element = 'cl' THEN 1 ELSE 0 END), COUNT(atom_id)) AS percent\nFROM \n  atom\nWHERE \n  molecule_id IN (\n    SELECT \n      molecule_id \n    FROM \n      bond \n    WHERE \n      bond_type = '-'\n  )",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "challenging"
  },
  {
    "idx": 264,
    "db_id": "toxicology",
    "question": "What are the labels for TR000, TR001 and TR002?",
    "evidence": "TR000, TR001 and TR002 are molecule id; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
    "predicted_sql": "SELECT m.label\nFROM molecule m\nWHERE m.molecule_id IN (TR000, TR001, TR002)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: TR000",
    "difficulty": "simple"
  },
  {
    "idx": 265,
    "db_id": "toxicology",
    "question": "List down the molecule id for non carcinogenic molecules.",
    "evidence": "label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT T.molecule_id FROM molecule AS T WHERE T.label = '-'",
    "predicted_sql": "SELECT m.molecule_id\nFROM molecule m\nWHERE m.label = '-'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 266,
    "db_id": "toxicology",
    "question": "Calculate the total carcinogenic molecules for molecule id from TR000 to TR030.",
    "evidence": "label = '+' mean molecules are carcinogenic",
    "gold_sql": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.molecule_id BETWEEN 'TR000' AND 'TR030' AND T.label = '+'",
    "predicted_sql": "SELECT \n  COUNT(DISTINCT m.molecule_id) \nFROM \n  molecule m \nWHERE \n  m.label = '+' \n  AND m.molecule_id BETWEEN 'TR000' AND 'TR030'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 267,
    "db_id": "toxicology",
    "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
    "evidence": "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
    "predicted_sql": "SELECT \n  m.molecule_id, \n  b.bond_type\nFROM \n  molecule m\n  LEFT JOIN bond b ON m.molecule_id = b.molecule_id\nWHERE \n  m.molecule_id BETWEEN 'TR000' AND 'TR050'\nORDER BY \n  m.molecule_id",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 268,
    "db_id": "toxicology",
    "question": "What are the elements for bond id TR001_10_11?",
    "evidence": "TR001_10_11 is the bond id;",
    "gold_sql": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
    "predicted_sql": "SELECT \n  a.element\nFROM \n  connected c \n  JOIN bond b ON c.bond_id = b.bond_id\n  JOIN atom a ON c.atom_id = a.atom_id\nWHERE \n  b.bond_id = 'TR001_10_11'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "challenging"
  },
  {
    "idx": 269,
    "db_id": "toxicology",
    "question": "How many bond id have element iodine?",
    "evidence": "iodine refers to element = 'i'",
    "gold_sql": "SELECT COUNT(T3.bond_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 'i'",
    "predicted_sql": "SELECT COUNT(DISTINCT bond_id)\nFROM connected\nWHERE EXISTS (\n  SELECT 1\n  FROM atom\n  WHERE atom.atom_id = connected.atom_id\n  AND atom.atom_id2 = connected.atom_id2\n  AND atom.element = 'i'\n)",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: atom.atom_id2",
    "difficulty": "simple"
  },
  {
    "idx": 270,
    "db_id": "toxicology",
    "question": "Among the molecules with element Calcium, are they mostly carcinogenic or non carcinogenic?",
    "evidence": "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; MAX(label)",
    "gold_sql": "SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca' GROUP BY T2.label ORDER BY COUNT(T2.label) DESC LIMIT 1",
    "predicted_sql": "SELECT \n  CASE \n    WHEN AVG(CASE WHEN label = '+' THEN 1 ELSE 0 END) > AVG(CASE WHEN label = '-' THEN 1 ELSE 0 END) \n    THEN 'carcinogenic'\n    ELSE 'non carcinogenic'\n  END AS result\nFROM \n  molecule m \nJOIN \n  atom a ON m.molecule_id = a.molecule_id \nWHERE \n  a.element = 'ca'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 271,
    "db_id": "toxicology",
    "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
    "evidence": "chlorine refers to element = 'cl'; carbon refers to element = 'c'",
    "gold_sql": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
    "predicted_sql": "SELECT * \nFROM connected \nWHERE bond_id = 'TR001_1_8' \nAND (SELECT element \n      FROM atom \n      WHERE atom_id IN (SELECT atom_id \n                         FROM connected \n                         WHERE bond_id = 'TR001_1_8')) \n  IN ('cl', 'c')",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 272,
    "db_id": "toxicology",
    "question": "List down two molecule id of triple bond non carcinogenic molecules with element carbon.",
    "evidence": "carbon refers to element = 'c'; triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element = 'c' AND T2.label = '-'",
    "predicted_sql": "SELECT m.molecule_id\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'c' AND b.bond_type = '#' AND m.label = '-'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 273,
    "db_id": "toxicology",
    "question": "What is the percentage of element chlorine in carcinogenic molecules?",
    "evidence": "chlorine refers to element = 'cl'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(element = 'pb'); COUNT(molecule_id)) as percentage where label = '+'",
    "gold_sql": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "predicted_sql": "SELECT DIVIDE(SUM(element = 'cl'), COUNT(molecule_id)) as percentage FROM molecule WHERE label = '+'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "moderate"
  },
  {
    "idx": 274,
    "db_id": "toxicology",
    "question": "List the toxicology elements associated with molecule TR001.",
    "evidence": "TR001 is the molecule id",
    "gold_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR001'",
    "predicted_sql": "SELECT a.element\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.molecule_id = 'TR001'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 275,
    "db_id": "toxicology",
    "question": "Give me the molecule ID of the double bond type.",
    "evidence": "double bond refers to bond_type = ' = ';",
    "gold_sql": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '='",
    "predicted_sql": "SELECT \n  m.molecule_id \nFROM \n  bond b \n  JOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE \n  b.bond_type ='= '",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 276,
    "db_id": "toxicology",
    "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
    "evidence": "first atom refers to atom_id; second atom refers to atom_id2; triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
    "predicted_sql": "SELECT \n  a1.atom_id AS first_atom_id, \n  a2.atom_id AS second_atom_id\nFROM \n  connected c\n  JOIN atom a1 ON c.atom_id = a1.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\n  JOIN bond b ON c.bond_id = b.bond_id\nWHERE \n  b.bond_type = '#'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 277,
    "db_id": "toxicology",
    "question": "What are the toxicology elements associated with bond ID TR000_1_2?",
    "evidence": "TR000_1_2 is the bond id;",
    "gold_sql": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR000_1_2'",
    "predicted_sql": "SELECT \n    a.element \nFROM \n    atom a \nJOIN \n    connected c ON a.atom_id = c.atom_id \nJOIN \n    connected c2 ON c.atom_id2 = c2.atom_id2 \nJOIN \n    bond b ON c2.bond_id = b.bond_id \nWHERE \n    b.bond_id = 'TR000_1_2'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 278,
    "db_id": "toxicology",
    "question": "How many of the single bond type molecules are non-carcinogenic?",
    "evidence": "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';",
    "gold_sql": "SELECT COUNT(DISTINCT T2.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
    "predicted_sql": "SELECT COUNT(*)\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_type = '-' AND m.label = '-'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 279,
    "db_id": "toxicology",
    "question": "What is the label for bond ID TR001_10_11?",
    "evidence": "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'",
    "predicted_sql": "SELECT \n  m.label\nFROM \n  molecule m\n  JOIN bond b ON m.molecule_id = b.molecule_id\nWHERE \n  b.bond_id = 'TR001_10_11'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 280,
    "db_id": "toxicology",
    "question": "Enumerate the bond ID of triple bond type molecules and tell me if they are carcinogenic or not.",
    "evidence": "triple bond refers to bond_type = '#'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
    "gold_sql": "SELECT DISTINCT T1.bond_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
    "predicted_sql": "SELECT \n  b.bond_id, \n  m.label\nFROM \n  bond b \n  JOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE \n  b.bond_type = '#'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "moderate"
  },
  {
    "idx": 281,
    "db_id": "toxicology",
    "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
    "evidence": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
    "gold_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
    "predicted_sql": "SELECT \n  element, \n  COUNT(*) AS count\nFROM \n  (\n    SELECT \n      s.element, \n      s.atom_id \n    FROM \n      molecule m \n    JOIN \n      atom s \n    ON \n      m.molecule_id = s.molecule_id \n    WHERE \n      m.label = '+' \n    JOIN \n      connected c \n    ON \n      s.atom_id = c.atom_id \n    JOIN \n      connected c2 \n    ON \n      c.atom_id2 = c2.atom_id \n    JOIN \n      atom t \n    ON \n      c2.atom_id = t.atom_id \n    WHERE \n      t.atom_id = (SELECT \n                    substr(atom_id, 7, 1) \n                  FROM \n                    atom \n                  WHERE \n                    molecule_id = m.molecule_id \n                  ORDER BY \n                    atom_id \n                  OFFSET 3 ROWS \n                  FETCH NEXT 1 ROW ONLY)\n  ) AS s \nGROUP BY \n  element",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"JOIN\": syntax error",
    "difficulty": "challenging"
  },
  {
    "idx": 282,
    "db_id": "toxicology",
    "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
    "evidence": "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
    "gold_sql": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
    "predicted_sql": "SELECT \n    ratio, \n    label\nFROM \n    (\n        SELECT \n            DIVIDE(SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END), \n                   COUNT(*)) AS ratio, \n            label\n        FROM \n            molecule \n        WHERE \n            molecule_id = 'TR006'\n        GROUP BY \n            label\n    ) AS subquery\nORDER BY \n    ratio",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "challenging"
  },
  {
    "idx": 283,
    "db_id": "toxicology",
    "question": "Identify whether the chemical compound that contains Calcium is carcinogenic.",
    "evidence": "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic;",
    "gold_sql": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'",
    "predicted_sql": "SELECT \n    m.label \nFROM \n    molecule m \nJOIN \n    atom a ON m.molecule_id = a.molecule_id \nWHERE \n    a.element = 'ca' \n    AND EXISTS (\n        SELECT 1 \n        FROM connected c \n        WHERE c.atom_id = a.atom_id \n        AND c.atom_id2 IN (\n            SELECT b.atom_id2 \n            FROM bond b \n            WHERE b.bond_type = 'covalent' \n            AND EXISTS (\n                SELECT 1 \n                FROM connected c2 \n                WHERE c2.atom_id = b.atom_id \n                AND c2.atom_id2 IN (\n                    SELECT m2.molecule_id \n                    FROM molecule m2 \n                    WHERE m2.label IN ('+', '-')\n                )\n            )\n        )\n    )",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Schema error: SQL error: no such column: b.atom_id2",
    "difficulty": "moderate"
  },
  {
    "idx": 284,
    "db_id": "toxicology",
    "question": "Determine the bond type that is formed in the chemical compound containing element Carbon.",
    "evidence": "Carbon refers to element = 'c'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'",
    "predicted_sql": "SELECT \n  b.bond_type, \n  COUNT(*) as count\nFROM \n  bond b \n  JOIN connected c ON b.bond_id = c.bond_id\n  JOIN atom a ON c.atom_id = a.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n  a.element = 'c' AND a2.element = 'c'\nGROUP BY \n  b.bond_type\nORDER BY \n  count DESC",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "moderate"
  },
  {
    "idx": 285,
    "db_id": "toxicology",
    "question": "Name chemical elements that form a bond TR001_10_11.",
    "evidence": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium; TR001_10_11 is the bond id; molecule id refers to SUBSTR(bond_id, 1, 5); atom 1 refers to SUBSTR(bond_id, 7, 2); atom 2 refers to SUBSTR(bond_id, 10, 2)",
    "gold_sql": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR001_10_11'",
    "predicted_sql": "SELECT DISTINCT \n    a.element \nFROM \n    connected c \nJOIN \n    atom a ON c.atom_id = a.atom_id \nWHERE \n    c.atom_id2 IN (\n        SELECT \n            atom_id2 \n        FROM \n            connected \n        WHERE \n            bond_id = 'TR001_10_11'\n    )\n    AND c.atom_id IN (\n        SELECT \n            atom_id \n        FROM \n            connected \n        WHERE \n            bond_id = 'TR001_10_11'\n    )",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "challenging"
  },
  {
    "idx": 286,
    "db_id": "toxicology",
    "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
    "evidence": "triple bond refers to bond_type = '#';",
    "gold_sql": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T",
    "predicted_sql": "SELECT \n  ROUND(\n    (\n      COUNT(DISTINCT m.molecule_id) \n      WHERE EXISTS (\n        SELECT 1 \n        FROM bond b \n        WHERE b.molecule_id = m.molecule_id AND b.bond_type = '#'\n      )\n    ) / \n    (SELECT COUNT(*) FROM molecule) * 100, \n  2\n) AS percentage_of_triple_bond_compounds\nFROM molecule m",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Syntax error: SQL error: near \"WHERE\": syntax error",
    "difficulty": "simple"
  },
  {
    "idx": 287,
    "db_id": "toxicology",
    "question": "Among all chemical compounds that contain molecule TR047, identify the percent that form a double-bond.",
    "evidence": "TR047 is the molecule id; double bond refers to bond_type = ' = '; percentage = DIVIDE(SUM(bond_type = ' = '), COUNT(all bond_id)) as percent where molecule_id = 'TR047'",
    "gold_sql": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T WHERE T.molecule_id = 'TR047'",
    "predicted_sql": "SELECT \n  DIVIDE(SUM(bond_type ='= '), COUNT(all bond_id)) as percent \nFROM \n  bond \nWHERE \n  molecule_id = 'TR047'",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "moderate"
  },
  {
    "idx": 288,
    "db_id": "toxicology",
    "question": "Identify whether the molecule that contains atom TR001_1 is carcinogenic.",
    "evidence": "label = '+' mean molecules are carcinogenic;",
    "gold_sql": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'",
    "predicted_sql": "SELECT \n    m.label \nFROM \n    molecule m \nJOIN \n    atom a ON m.molecule_id = a.molecule_id \nWHERE \n    a.element = 'TR001_1'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 289,
    "db_id": "toxicology",
    "question": "Is molecule TR151 carcinogenic?",
    "evidence": "label = '+' mean molecules are carcinogenic;",
    "gold_sql": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR151'",
    "predicted_sql": "SELECT m.label\nFROM molecule m\nWHERE m.molecule_id = 'TR151'\nAND m.label = '+'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 290,
    "db_id": "toxicology",
    "question": "Which toxic element can be found in the molecule TR151?",
    "evidence": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
    "gold_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'",
    "predicted_sql": "SELECT element\nFROM atom\nJOIN molecule ON atom.molecule_id = molecule.molecule_id\nWHERE molecule.label = 'TR151'\nAND element NOT IN ('c', 'h', 'o','s', 'n', 'p', 'na', 'br', 'f', 'i','sn', 'pb', 'te', 'ca')",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "challenging"
  },
  {
    "idx": 291,
    "db_id": "toxicology",
    "question": "How many chemical compounds in the database are identified as carcinogenic.",
    "evidence": "label = '+' mean molecules are carcinogenic;",
    "gold_sql": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
    "predicted_sql": "SELECT COUNT(*)\nFROM molecule\nWHERE label = '+'",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 292,
    "db_id": "toxicology",
    "question": "Identify the atoms belong to the molecule with ID between TR010 to TR050 that contain the element carbon.",
    "evidence": "carbon refers to element = 'c'; between TR010 to TR050 refers to substr(molecule_id, 3, 3)>=10 AND substr(molecule_id, 3, 3) <= 50",
    "gold_sql": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'",
    "predicted_sql": "SELECT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.molecule_id BETWEEN 'TR010' AND 'TR050'\nAND a.element = 'c'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 293,
    "db_id": "toxicology",
    "question": "How many atoms belong to the molecule labeled with carcinogenic compounds?",
    "evidence": "label = '+' mean molecules are carcinogenic;",
    "gold_sql": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "predicted_sql": "SELECT COUNT(*)\nFROM atom\nWHERE molecule_id IN (\n  SELECT molecule_id\n  FROM molecule\n  WHERE label = '+'\n)",
    "is_valid": true,
    "is_exec_correct": true,
    "error_message": "",
    "difficulty": "simple"
  },
  {
    "idx": 294,
    "db_id": "toxicology",
    "question": "Which bond ids are double-bond with carcinogenic compound?",
    "evidence": "label = '+' mean molecules are carcinogenic; double bond refers to bond_type = ' = ';",
    "gold_sql": "SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='",
    "predicted_sql": "SELECT \n  b.bond_id\nFROM \n  bond b\n  JOIN molecule m ON b.molecule_id = m.molecule_id\n  JOIN connected c ON b.bond_id = c.bond_id\nWHERE \n  m.label = '+' AND \n  b.bond_type ='= '",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 295,
    "db_id": "toxicology",
    "question": "How many atoms belong to the molecule that element is hydrogen and labeled with carcinogenic compound?",
    "evidence": "label = '+' mean molecules are carcinogenic; hydrogen refers to element = h'",
    "gold_sql": "SELECT COUNT(T1.atom_id) AS atomnums_h FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'h'",
    "predicted_sql": "SELECT COUNT(DISTINCT a.atom_id)\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+' AND a.element = 'H'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 296,
    "db_id": "toxicology",
    "question": "Indicate the molecule id is belonging to the TR000_1_2 bond that has the first atom named TR000_1.",
    "evidence": "",
    "gold_sql": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'",
    "predicted_sql": "SELECT \n    m.molecule_id\nFROM \n    molecule m\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nJOIN \n    connected c ON b.bond_id = c.bond_id\nJOIN \n    atom a ON c.atom_id = a.atom_id\nWHERE \n    a.element = 'TR000_1' \n    AND c.atom_id2 IN (\n        SELECT \n            atom_id2\n        FROM \n            connected\n        WHERE \n            atom_id = (SELECT \n                        atom_id\n                    FROM \n                        atom\n                    WHERE \n                        element = 'TR000_1')\n    )\n    AND b.bond_type = 'TR000_1_2'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 297,
    "db_id": "toxicology",
    "question": "Among the atoms that contain element carbon, which one does not contain compound carcinogenic?",
    "evidence": "label = '-' means molecules are non-carcinogenic; carbon refers to element = 'c'",
    "gold_sql": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
    "predicted_sql": "SELECT a.element, m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c'\nAND NOT EXISTS (\n  SELECT 1\n  FROM connected c\n  JOIN bond b ON c.bond_id = b.bond_id\n  JOIN molecule m2 ON b.molecule_id = m2.molecule_id\n  WHERE c.atom_id = a.atom_id\n  AND c.atom_id2 = a.atom_id\n  AND m2.label = '-'\n)",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  },
  {
    "idx": 298,
    "db_id": "toxicology",
    "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
    "evidence": "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'h'), COUNT(molecule_id)) * 100.0",
    "gold_sql": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
    "predicted_sql": "SELECT \n    DIVIDE(\n        SUM(\n            CASE \n                WHEN label = '+' AND element = 'h' THEN 1 \n                ELSE 0 \n            END\n        ), \n        COUNT(molecule_id)\n    ) * 100.0 AS percentage\nFROM \n    molecule",
    "is_valid": false,
    "is_exec_correct": false,
    "error_message": "Execution error: SQL error: no such function: DIVIDE",
    "difficulty": "moderate"
  },
  {
    "idx": 299,
    "db_id": "toxicology",
    "question": "Is molecule TR124 carcinogenic?",
    "evidence": "label = '+' mean molecules are carcinogenic;",
    "gold_sql": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
    "predicted_sql": "SELECT * FROM molecule WHERE label = '+' AND molecule_id = 'TR124'",
    "is_valid": true,
    "is_exec_correct": false,
    "error_message": "Results do not match",
    "difficulty": "simple"
  }
]